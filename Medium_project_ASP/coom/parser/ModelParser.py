# Generated from Model.g4 by ANTLR 4.9
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
    from typing import TextIO
else:
    from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3R")
        buf.write("\u026b\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\3\2\3\2\3\2\3\2\7")
        buf.write("\2u\n\2\f\2\16\2x\13\2\3\2\3\2\3\3\3\3\3\3\3\3\3\3\3\3")
        buf.write("\7\3\u0082\n\3\f\3\16\3\u0085\13\3\5\3\u0087\n\3\3\3\3")
        buf.write("\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4\u0092\n\4\f\4\16\4")
        buf.write("\u0095\13\4\5\4\u0097\n\4\3\4\3\4\3\5\3\5\3\5\3\5\3\5")
        buf.write("\5\5\u00a0\n\5\3\5\3\5\3\5\5\5\u00a5\n\5\7\5\u00a7\n\5")
        buf.write("\f\5\16\5\u00aa\13\5\5\5\u00ac\n\5\3\5\3\5\3\6\3\6\5\6")
        buf.write("\u00b2\n\6\3\6\3\6\3\7\3\7\3\7\3\7\7\7\u00ba\n\7\f\7\16")
        buf.write("\7\u00bd\13\7\3\7\3\7\3\7\3\7\7\7\u00c3\n\7\f\7\16\7\u00c6")
        buf.write("\13\7\5\7\u00c8\n\7\3\7\3\7\3\7\3\7\7\7\u00ce\n\7\f\7")
        buf.write("\16\7\u00d1\13\7\5\7\u00d3\n\7\3\7\3\7\3\b\5\b\u00d8\n")
        buf.write("\b\3\b\5\b\u00db\n\b\3\b\3\b\3\b\5\b\u00e0\n\b\3\t\3\t")
        buf.write("\3\t\5\t\u00e5\n\t\5\t\u00e7\n\t\3\n\3\n\3\n\3\13\3\13")
        buf.write("\3\13\3\13\3\13\5\13\u00f1\n\13\3\13\7\13\u00f4\n\13\f")
        buf.write("\13\16\13\u00f7\13\13\3\13\3\13\5\13\u00fb\n\13\3\f\3")
        buf.write("\f\3\f\3\f\3\f\3\f\3\f\5\f\u0104\n\f\3\f\5\f\u0107\n\f")
        buf.write("\3\r\3\r\5\r\u010b\n\r\3\r\5\r\u010e\n\r\3\r\3\r\3\r\3")
        buf.write("\r\5\r\u0114\n\r\3\16\3\16\5\16\u0118\n\16\3\16\5\16\u011b")
        buf.write("\n\16\3\17\3\17\3\17\3\17\3\17\3\20\3\20\3\20\5\20\u0125")
        buf.write("\n\20\3\20\3\20\3\20\5\20\u012a\n\20\3\20\3\20\3\20\7")
        buf.write("\20\u012f\n\20\f\20\16\20\u0132\13\20\3\20\3\20\3\20\3")
        buf.write("\20\3\20\3\20\3\20\3\20\5\20\u013c\n\20\3\21\3\21\3\21")
        buf.write("\3\21\5\21\u0142\n\21\3\21\7\21\u0145\n\21\f\21\16\21")
        buf.write("\u0148\13\21\3\21\3\21\3\21\3\21\3\21\3\21\7\21\u0150")
        buf.write("\n\21\f\21\16\21\u0153\13\21\5\21\u0155\n\21\3\22\3\22")
        buf.write("\3\22\3\23\3\23\3\23\5\23\u015d\n\23\3\23\7\23\u0160\n")
        buf.write("\23\f\23\16\23\u0163\13\23\3\24\3\24\3\24\3\24\3\24\3")
        buf.write("\24\3\24\5\24\u016c\n\24\3\24\3\24\5\24\u0170\n\24\5\24")
        buf.write("\u0172\n\24\3\25\3\25\3\25\3\25\3\25\3\26\3\26\3\26\3")
        buf.write("\26\3\26\3\27\3\27\3\27\3\30\3\30\3\30\5\30\u0184\n\30")
        buf.write("\3\30\3\30\3\31\3\31\3\31\7\31\u018b\n\31\f\31\16\31\u018e")
        buf.write("\13\31\3\31\3\31\3\31\5\31\u0193\n\31\3\31\3\31\3\32\3")
        buf.write("\32\3\32\3\33\3\33\3\33\5\33\u019d\n\33\3\33\3\33\3\34")
        buf.write("\3\34\3\34\3\34\5\34\u01a5\n\34\3\34\7\34\u01a8\n\34\f")
        buf.write("\34\16\34\u01ab\13\34\3\34\3\34\3\35\3\35\3\35\3\35\5")
        buf.write("\35\u01b3\n\35\3\35\7\35\u01b6\n\35\f\35\16\35\u01b9\13")
        buf.write("\35\3\35\3\35\3\35\5\35\u01be\n\35\3\36\5\36\u01c1\n\36")
        buf.write("\3\36\3\36\3\37\3\37\5\37\u01c7\n\37\3 \3 \5 \u01cb\n")
        buf.write(" \3!\5!\u01ce\n!\3!\3!\3\"\3\"\3#\3#\3#\3$\3$\3$\3%\3")
        buf.write("%\3%\7%\u01dd\n%\f%\16%\u01e0\13%\3&\3&\3&\3&\3&\5&\u01e7")
        buf.write("\n&\3&\3&\5&\u01eb\n&\3\'\3\'\3\'\3\'\3\'\5\'\u01f2\n")
        buf.write("\'\5\'\u01f4\n\'\3(\3(\3)\3)\3)\7)\u01fb\n)\f)\16)\u01fe")
        buf.write("\13)\3*\3*\3*\7*\u0203\n*\f*\16*\u0206\13*\3+\3+\3+\3")
        buf.write("+\3+\3+\3+\5+\u020f\n+\3,\3,\7,\u0213\n,\f,\16,\u0216")
        buf.write("\13,\3-\3-\3-\3.\3.\3/\3/\3/\7/\u0220\n/\f/\16/\u0223")
        buf.write("\13/\3\60\3\60\3\60\7\60\u0228\n\60\f\60\16\60\u022b\13")
        buf.write("\60\3\61\3\61\3\61\7\61\u0230\n\61\f\61\16\61\u0233\13")
        buf.write("\61\3\62\3\62\3\62\7\62\u0238\n\62\f\62\16\62\u023b\13")
        buf.write("\62\3\63\3\63\3\63\7\63\u0240\n\63\f\63\16\63\u0243\13")
        buf.write("\63\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64\3\64")
        buf.write("\5\64\u024f\n\64\3\65\3\65\3\65\3\65\3\65\7\65\u0256\n")
        buf.write("\65\f\65\16\65\u0259\13\65\3\65\3\65\3\66\3\66\3\66\3")
        buf.write("\66\5\66\u0261\n\66\3\67\3\67\38\38\38\38\38\38\38\2\2")
        buf.write("9\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62")
        buf.write("\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjln\2\r\4\2KKMM\5\2\f")
        buf.write("\fKKMM\3\2\31\32\3\2\"$\3\2&*\3\2-.\4\2\61\61KL\4\2\16")
        buf.write("\16\62<\4\2HHJN\3\2=>\3\2HJ\2\u028e\2v\3\2\2\2\4{\3\2")
        buf.write("\2\2\6\u008a\3\2\2\2\b\u009a\3\2\2\2\n\u00af\3\2\2\2\f")
        buf.write("\u00b5\3\2\2\2\16\u00d7\3\2\2\2\20\u00e1\3\2\2\2\22\u00e8")
        buf.write("\3\2\2\2\24\u00eb\3\2\2\2\26\u0106\3\2\2\2\30\u0108\3")
        buf.write("\2\2\2\32\u0115\3\2\2\2\34\u011c\3\2\2\2\36\u0124\3\2")
        buf.write("\2\2 \u013d\3\2\2\2\"\u0156\3\2\2\2$\u0159\3\2\2\2&\u0171")
        buf.write("\3\2\2\2(\u0173\3\2\2\2*\u0178\3\2\2\2,\u017d\3\2\2\2")
        buf.write(".\u0180\3\2\2\2\60\u018c\3\2\2\2\62\u0196\3\2\2\2\64\u0199")
        buf.write("\3\2\2\2\66\u01a0\3\2\2\28\u01bd\3\2\2\2:\u01c0\3\2\2")
        buf.write("\2<\u01c6\3\2\2\2>\u01ca\3\2\2\2@\u01cd\3\2\2\2B\u01d1")
        buf.write("\3\2\2\2D\u01d3\3\2\2\2F\u01d6\3\2\2\2H\u01d9\3\2\2\2")
        buf.write("J\u01e1\3\2\2\2L\u01f3\3\2\2\2N\u01f5\3\2\2\2P\u01f7\3")
        buf.write("\2\2\2R\u01ff\3\2\2\2T\u020e\3\2\2\2V\u0210\3\2\2\2X\u0217")
        buf.write("\3\2\2\2Z\u021a\3\2\2\2\\\u021c\3\2\2\2^\u0224\3\2\2\2")
        buf.write("`\u022c\3\2\2\2b\u0234\3\2\2\2d\u023c\3\2\2\2f\u024e\3")
        buf.write("\2\2\2h\u0250\3\2\2\2j\u0260\3\2\2\2l\u0262\3\2\2\2n\u0264")
        buf.write("\3\2\2\2pu\5\4\3\2qu\5\6\4\2ru\5\b\5\2su\5\n\6\2tp\3\2")
        buf.write("\2\2tq\3\2\2\2tr\3\2\2\2ts\3\2\2\2ux\3\2\2\2vt\3\2\2\2")
        buf.write("vw\3\2\2\2wy\3\2\2\2xv\3\2\2\2yz\7\2\2\3z\3\3\2\2\2{|")
        buf.write("\7\3\2\2|\u0086\7\4\2\2}\u0083\5\16\b\2~\177\5<\37\2\177")
        buf.write("\u0080\5\16\b\2\u0080\u0082\3\2\2\2\u0081~\3\2\2\2\u0082")
        buf.write("\u0085\3\2\2\2\u0083\u0081\3\2\2\2\u0083\u0084\3\2\2\2")
        buf.write("\u0084\u0087\3\2\2\2\u0085\u0083\3\2\2\2\u0086}\3\2\2")
        buf.write("\2\u0086\u0087\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u0089")
        buf.write("\7\5\2\2\u0089\5\3\2\2\2\u008a\u008b\7\6\2\2\u008b\u008c")
        buf.write("\5l\67\2\u008c\u0096\7\4\2\2\u008d\u0093\5\16\b\2\u008e")
        buf.write("\u008f\5<\37\2\u008f\u0090\5\16\b\2\u0090\u0092\3\2\2")
        buf.write("\2\u0091\u008e\3\2\2\2\u0092\u0095\3\2\2\2\u0093\u0091")
        buf.write("\3\2\2\2\u0093\u0094\3\2\2\2\u0094\u0097\3\2\2\2\u0095")
        buf.write("\u0093\3\2\2\2\u0096\u008d\3\2\2\2\u0096\u0097\3\2\2\2")
        buf.write("\u0097\u0098\3\2\2\2\u0098\u0099\7\5\2\2\u0099\7\3\2\2")
        buf.write("\2\u009a\u009b\7\7\2\2\u009b\u009c\5l\67\2\u009c\u00ab")
        buf.write("\7\4\2\2\u009d\u00a0\5\22\n\2\u009e\u00a0\5\24\13\2\u009f")
        buf.write("\u009d\3\2\2\2\u009f\u009e\3\2\2\2\u00a0\u00a8\3\2\2\2")
        buf.write("\u00a1\u00a4\5<\37\2\u00a2\u00a5\5\22\n\2\u00a3\u00a5")
        buf.write("\5\24\13\2\u00a4\u00a2\3\2\2\2\u00a4\u00a3\3\2\2\2\u00a5")
        buf.write("\u00a7\3\2\2\2\u00a6\u00a1\3\2\2\2\u00a7\u00aa\3\2\2\2")
        buf.write("\u00a8\u00a6\3\2\2\2\u00a8\u00a9\3\2\2\2\u00a9\u00ac\3")
        buf.write("\2\2\2\u00aa\u00a8\3\2\2\2\u00ab\u009f\3\2\2\2\u00ab\u00ac")
        buf.write("\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad\u00ae\7\5\2\2\u00ae")
        buf.write("\t\3\2\2\2\u00af\u00b1\7\b\2\2\u00b0\u00b2\5l\67\2\u00b1")
        buf.write("\u00b0\3\2\2\2\u00b1\u00b2\3\2\2\2\u00b2\u00b3\3\2\2\2")
        buf.write("\u00b3\u00b4\5\f\7\2\u00b4\13\3\2\2\2\u00b5\u00bb\7\4")
        buf.write("\2\2\u00b6\u00b7\5\34\17\2\u00b7\u00b8\5<\37\2\u00b8\u00ba")
        buf.write("\3\2\2\2\u00b9\u00b6\3\2\2\2\u00ba\u00bd\3\2\2\2\u00bb")
        buf.write("\u00b9\3\2\2\2\u00bb\u00bc\3\2\2\2\u00bc\u00c7\3\2\2\2")
        buf.write("\u00bd\u00bb\3\2\2\2\u00be\u00c4\5\60\31\2\u00bf\u00c0")
        buf.write("\5<\37\2\u00c0\u00c1\5\60\31\2\u00c1\u00c3\3\2\2\2\u00c2")
        buf.write("\u00bf\3\2\2\2\u00c3\u00c6\3\2\2\2\u00c4\u00c2\3\2\2\2")
        buf.write("\u00c4\u00c5\3\2\2\2\u00c5\u00c8\3\2\2\2\u00c6\u00c4\3")
        buf.write("\2\2\2\u00c7\u00be\3\2\2\2\u00c7\u00c8\3\2\2\2\u00c8\u00d2")
        buf.write("\3\2\2\2\u00c9\u00cf\5\36\20\2\u00ca\u00cb\5<\37\2\u00cb")
        buf.write("\u00cc\5\36\20\2\u00cc\u00ce\3\2\2\2\u00cd\u00ca\3\2\2")
        buf.write("\2\u00ce\u00d1\3\2\2\2\u00cf\u00cd\3\2\2\2\u00cf\u00d0")
        buf.write("\3\2\2\2\u00d0\u00d3\3\2\2\2\u00d1\u00cf\3\2\2\2\u00d2")
        buf.write("\u00c9\3\2\2\2\u00d2\u00d3\3\2\2\2\u00d3\u00d4\3\2\2\2")
        buf.write("\u00d4\u00d5\7\5\2\2\u00d5\r\3\2\2\2\u00d6\u00d8\7\t\2")
        buf.write("\2\u00d7\u00d6\3\2\2\2\u00d7\u00d8\3\2\2\2\u00d8\u00da")
        buf.write("\3\2\2\2\u00d9\u00db\5\20\t\2\u00da\u00d9\3\2\2\2\u00da")
        buf.write("\u00db\3\2\2\2\u00db\u00dc\3\2\2\2\u00dc\u00df\5\26\f")
        buf.write("\2\u00dd\u00de\7\n\2\2\u00de\u00e0\7K\2\2\u00df\u00dd")
        buf.write("\3\2\2\2\u00df\u00e0\3\2\2\2\u00e0\17\3\2\2\2\u00e1\u00e6")
        buf.write("\t\2\2\2\u00e2\u00e4\7\13\2\2\u00e3\u00e5\t\3\2\2\u00e4")
        buf.write("\u00e3\3\2\2\2\u00e4\u00e5\3\2\2\2\u00e5\u00e7\3\2\2\2")
        buf.write("\u00e6\u00e2\3\2\2\2\u00e6\u00e7\3\2\2\2\u00e7\21\3\2")
        buf.write("\2\2\u00e8\u00e9\7\r\2\2\u00e9\u00ea\5\26\f\2\u00ea\23")
        buf.write("\3\2\2\2\u00eb\u00fa\5l\67\2\u00ec\u00ed\7\16\2\2\u00ed")
        buf.write("\u00ee\7\17\2\2\u00ee\u00f5\5> \2\u00ef\u00f1\7\20\2\2")
        buf.write("\u00f0\u00ef\3\2\2\2\u00f0\u00f1\3\2\2\2\u00f1\u00f2\3")
        buf.write("\2\2\2\u00f2\u00f4\5> \2\u00f3\u00f0\3\2\2\2\u00f4\u00f7")
        buf.write("\3\2\2\2\u00f5\u00f3\3\2\2\2\u00f5\u00f6\3\2\2\2\u00f6")
        buf.write("\u00f8\3\2\2\2\u00f7\u00f5\3\2\2\2\u00f8\u00f9\7\21\2")
        buf.write("\2\u00f9\u00fb\3\2\2\2\u00fa\u00ec\3\2\2\2\u00fa\u00fb")
        buf.write("\3\2\2\2\u00fb\25\3\2\2\2\u00fc\u00fd\5\30\r\2\u00fd\u00fe")
        buf.write("\5l\67\2\u00fe\u0107\3\2\2\2\u00ff\u0100\5\32\16\2\u0100")
        buf.write("\u0101\5l\67\2\u0101\u0107\3\2\2\2\u0102\u0104\5l\67\2")
        buf.write("\u0103\u0102\3\2\2\2\u0103\u0104\3\2\2\2\u0104\u0105\3")
        buf.write("\2\2\2\u0105\u0107\5l\67\2\u0106\u00fc\3\2\2\2\u0106\u00ff")
        buf.write("\3\2\2\2\u0106\u0103\3\2\2\2\u0107\27\3\2\2\2\u0108\u010a")
        buf.write("\7\22\2\2\u0109\u010b\5F$\2\u010a\u0109\3\2\2\2\u010a")
        buf.write("\u010b\3\2\2\2\u010b\u010d\3\2\2\2\u010c\u010e\5D#\2\u010d")
        buf.write("\u010c\3\2\2\2\u010d\u010e\3\2\2\2\u010e\u0113\3\2\2\2")
        buf.write("\u010f\u0110\5@!\2\u0110\u0111\7\23\2\2\u0111\u0112\5")
        buf.write("@!\2\u0112\u0114\3\2\2\2\u0113\u010f\3\2\2\2\u0113\u0114")
        buf.write("\3\2\2\2\u0114\31\3\2\2\2\u0115\u0117\7\24\2\2\u0116\u0118")
        buf.write("\7\25\2\2\u0117\u0116\3\2\2\2\u0117\u0118\3\2\2\2\u0118")
        buf.write("\u011a\3\2\2\2\u0119\u011b\7K\2\2\u011a\u0119\3\2\2\2")
        buf.write("\u011a\u011b\3\2\2\2\u011b\33\3\2\2\2\u011c\u011d\7\26")
        buf.write("\2\2\u011d\u011e\5l\67\2\u011e\u011f\7\16\2\2\u011f\u0120")
        buf.write("\5Z.\2\u0120\35\3\2\2\2\u0121\u0122\5\"\22\2\u0122\u0123")
        buf.write("\5<\37\2\u0123\u0125\3\2\2\2\u0124\u0121\3\2\2\2\u0124")
        buf.write("\u0125\3\2\2\2\u0125\u0129\3\2\2\2\u0126\u0127\5$\23\2")
        buf.write("\u0127\u0128\5<\37\2\u0128\u012a\3\2\2\2\u0129\u0126\3")
        buf.write("\2\2\2\u0129\u012a\3\2\2\2\u012a\u0130\3\2\2\2\u012b\u012c")
        buf.write("\5&\24\2\u012c\u012d\5<\37\2\u012d\u012f\3\2\2\2\u012e")
        buf.write("\u012b\3\2\2\2\u012f\u0132\3\2\2\2\u0130\u012e\3\2\2\2")
        buf.write("\u0130\u0131\3\2\2\2\u0131\u013b\3\2\2\2\u0132\u0130\3")
        buf.write("\2\2\2\u0133\u013c\5\f\7\2\u0134\u013c\5(\25\2\u0135\u013c")
        buf.write("\5*\26\2\u0136\u013c\5,\27\2\u0137\u013c\5.\30\2\u0138")
        buf.write("\u013c\5\62\32\2\u0139\u013c\5\64\33\2\u013a\u013c\5 ")
        buf.write("\21\2\u013b\u0133\3\2\2\2\u013b\u0134\3\2\2\2\u013b\u0135")
        buf.write("\3\2\2\2\u013b\u0136\3\2\2\2\u013b\u0137\3\2\2\2\u013b")
        buf.write("\u0138\3\2\2\2\u013b\u0139\3\2\2\2\u013b\u013a\3\2\2\2")
        buf.write("\u013c\37\3\2\2\2\u013d\u013e\7\27\2\2\u013e\u013f\7\17")
        buf.write("\2\2\u013f\u0146\5Z.\2\u0140\u0142\7\20\2\2\u0141\u0140")
        buf.write("\3\2\2\2\u0141\u0142\3\2\2\2\u0142\u0143\3\2\2\2\u0143")
        buf.write("\u0145\5Z.\2\u0144\u0141\3\2\2\2\u0145\u0148\3\2\2\2\u0146")
        buf.write("\u0144\3\2\2\2\u0146\u0147\3\2\2\2\u0147\u0149\3\2\2\2")
        buf.write("\u0148\u0146\3\2\2\2\u0149\u014a\7\21\2\2\u014a\u0154")
        buf.write("\5<\37\2\u014b\u0151\5\66\34\2\u014c\u014d\5<\37\2\u014d")
        buf.write("\u014e\5\66\34\2\u014e\u0150\3\2\2\2\u014f\u014c\3\2\2")
        buf.write("\2\u0150\u0153\3\2\2\2\u0151\u014f\3\2\2\2\u0151\u0152")
        buf.write("\3\2\2\2\u0152\u0155\3\2\2\2\u0153\u0151\3\2\2\2\u0154")
        buf.write("\u014b\3\2\2\2\u0154\u0155\3\2\2\2\u0155!\3\2\2\2\u0156")
        buf.write("\u0157\7\30\2\2\u0157\u0158\5l\67\2\u0158#\3\2\2\2\u0159")
        buf.write("\u015a\t\4\2\2\u015a\u0161\7J\2\2\u015b\u015d\7\20\2\2")
        buf.write("\u015c\u015b\3\2\2\2\u015c\u015d\3\2\2\2\u015d\u015e\3")
        buf.write("\2\2\2\u015e\u0160\7J\2\2\u015f\u015c\3\2\2\2\u0160\u0163")
        buf.write("\3\2\2\2\u0161\u015f\3\2\2\2\u0161\u0162\3\2\2\2\u0162")
        buf.write("%\3\2\2\2\u0163\u0161\3\2\2\2\u0164\u0165\7\33\2\2\u0165")
        buf.write("\u0172\5N(\2\u0166\u016f\7\34\2\2\u0167\u0168\7\35\2\2")
        buf.write("\u0168\u016b\5n8\2\u0169\u016a\7\36\2\2\u016a\u016c\5")
        buf.write("n8\2\u016b\u0169\3\2\2\2\u016b\u016c\3\2\2\2\u016c\u0170")
        buf.write("\3\2\2\2\u016d\u016e\7\36\2\2\u016e\u0170\5n8\2\u016f")
        buf.write("\u0167\3\2\2\2\u016f\u016d\3\2\2\2\u0170\u0172\3\2\2\2")
        buf.write("\u0171\u0164\3\2\2\2\u0171\u0166\3\2\2\2\u0172\'\3\2\2")
        buf.write("\2\u0173\u0174\7\37\2\2\u0174\u0175\5H%\2\u0175\u0176")
        buf.write("\7\16\2\2\u0176\u0177\5Z.\2\u0177)\3\2\2\2\u0178\u0179")
        buf.write("\7 \2\2\u0179\u017a\5H%\2\u017a\u017b\7\16\2\2\u017b\u017c")
        buf.write("\5Z.\2\u017c+\3\2\2\2\u017d\u017e\7!\2\2\u017e\u017f\5")
        buf.write("H%\2\u017f-\3\2\2\2\u0180\u0183\t\5\2\2\u0181\u0182\7")
        buf.write("\n\2\2\u0182\u0184\7K\2\2\u0183\u0181\3\2\2\2\u0183\u0184")
        buf.write("\3\2\2\2\u0184\u0185\3\2\2\2\u0185\u0186\5H%\2\u0186/")
        buf.write("\3\2\2\2\u0187\u0188\5&\24\2\u0188\u0189\5<\37\2\u0189")
        buf.write("\u018b\3\2\2\2\u018a\u0187\3\2\2\2\u018b\u018e\3\2\2\2")
        buf.write("\u018c\u018a\3\2\2\2\u018c\u018d\3\2\2\2\u018d\u018f\3")
        buf.write("\2\2\2\u018e\u018c\3\2\2\2\u018f\u0192\7%\2\2\u0190\u0191")
        buf.write("\7\n\2\2\u0191\u0193\t\6\2\2\u0192\u0190\3\2\2\2\u0192")
        buf.write("\u0193\3\2\2\2\u0193\u0194\3\2\2\2\u0194\u0195\5l\67\2")
        buf.write("\u0195\61\3\2\2\2\u0196\u0197\7+\2\2\u0197\u0198\5N(\2")
        buf.write("\u0198\63\3\2\2\2\u0199\u019c\7,\2\2\u019a\u019b\7\n\2")
        buf.write("\2\u019b\u019d\7K\2\2\u019c\u019a\3\2\2\2\u019c\u019d")
        buf.write("\3\2\2\2\u019d\u019e\3\2\2\2\u019e\u019f\5N(\2\u019f\65")
        buf.write("\3\2\2\2\u01a0\u01a1\t\7\2\2\u01a1\u01a2\7\17\2\2\u01a2")
        buf.write("\u01a9\58\35\2\u01a3\u01a5\7\20\2\2\u01a4\u01a3\3\2\2")
        buf.write("\2\u01a4\u01a5\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\u01a8")
        buf.write("\58\35\2\u01a7\u01a4\3\2\2\2\u01a8\u01ab\3\2\2\2\u01a9")
        buf.write("\u01a7\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa\u01ac\3\2\2\2")
        buf.write("\u01ab\u01a9\3\2\2\2\u01ac\u01ad\7\21\2\2\u01ad\67\3\2")
        buf.write("\2\2\u01ae\u01be\7/\2\2\u01af\u01b0\7\17\2\2\u01b0\u01b7")
        buf.write("\5:\36\2\u01b1\u01b3\7\20\2\2\u01b2\u01b1\3\2\2\2\u01b2")
        buf.write("\u01b3\3\2\2\2\u01b3\u01b4\3\2\2\2\u01b4\u01b6\5:\36\2")
        buf.write("\u01b5\u01b2\3\2\2\2\u01b6\u01b9\3\2\2\2\u01b7\u01b5\3")
        buf.write("\2\2\2\u01b7\u01b8\3\2\2\2\u01b8\u01ba\3\2\2\2\u01b9\u01b7")
        buf.write("\3\2\2\2\u01ba\u01bb\7\21\2\2\u01bb\u01be\3\2\2\2\u01bc")
        buf.write("\u01be\5:\36\2\u01bd\u01ae\3\2\2\2\u01bd\u01af\3\2\2\2")
        buf.write("\u01bd\u01bc\3\2\2\2\u01be9\3\2\2\2\u01bf\u01c1\5B\"\2")
        buf.write("\u01c0\u01bf\3\2\2\2\u01c0\u01c1\3\2\2\2\u01c1\u01c2\3")
        buf.write("\2\2\2\u01c2\u01c3\5Z.\2\u01c3;\3\2\2\2\u01c4\u01c7\7")
        buf.write("\60\2\2\u01c5\u01c7\b\37\1\2\u01c6\u01c4\3\2\2\2\u01c6")
        buf.write("\u01c5\3\2\2\2\u01c7=\3\2\2\2\u01c8\u01cb\5@!\2\u01c9")
        buf.write("\u01cb\5l\67\2\u01ca\u01c8\3\2\2\2\u01ca\u01c9\3\2\2\2")
        buf.write("\u01cb?\3\2\2\2\u01cc\u01ce\7\23\2\2\u01cd\u01cc\3\2\2")
        buf.write("\2\u01cd\u01ce\3\2\2\2\u01ce\u01cf\3\2\2\2\u01cf\u01d0")
        buf.write("\t\b\2\2\u01d0A\3\2\2\2\u01d1\u01d2\t\t\2\2\u01d2C\3\2")
        buf.write("\2\2\u01d3\u01d4\7\n\2\2\u01d4\u01d5\t\n\2\2\u01d5E\3")
        buf.write("\2\2\2\u01d6\u01d7\t\13\2\2\u01d7\u01d8\7N\2\2\u01d8G")
        buf.write("\3\2\2\2\u01d9\u01de\5J&\2\u01da\u01db\7=\2\2\u01db\u01dd")
        buf.write("\5J&\2\u01dc\u01da\3\2\2\2\u01dd\u01e0\3\2\2\2\u01de\u01dc")
        buf.write("\3\2\2\2\u01de\u01df\3\2\2\2\u01dfI\3\2\2\2\u01e0\u01de")
        buf.write("\3\2\2\2\u01e1\u01ea\5l\67\2\u01e2\u01e3\7?\2\2\u01e3")
        buf.write("\u01e6\5L\'\2\u01e4\u01e5\7\13\2\2\u01e5\u01e7\5L\'\2")
        buf.write("\u01e6\u01e4\3\2\2\2\u01e6\u01e7\3\2\2\2\u01e7\u01e8\3")
        buf.write("\2\2\2\u01e8\u01e9\7@\2\2\u01e9\u01eb\3\2\2\2\u01ea\u01e2")
        buf.write("\3\2\2\2\u01ea\u01eb\3\2\2\2\u01ebK\3\2\2\2\u01ec\u01f4")
        buf.write("\7J\2\2\u01ed\u01f4\7K\2\2\u01ee\u01f1\7A\2\2\u01ef\u01f0")
        buf.write("\7\23\2\2\u01f0\u01f2\7K\2\2\u01f1\u01ef\3\2\2\2\u01f1")
        buf.write("\u01f2\3\2\2\2\u01f2\u01f4\3\2\2\2\u01f3\u01ec\3\2\2\2")
        buf.write("\u01f3\u01ed\3\2\2\2\u01f3\u01ee\3\2\2\2\u01f4M\3\2\2")
        buf.write("\2\u01f5\u01f6\5P)\2\u01f6O\3\2\2\2\u01f7\u01fc\5R*\2")
        buf.write("\u01f8\u01f9\7B\2\2\u01f9\u01fb\5R*\2\u01fa\u01f8\3\2")
        buf.write("\2\2\u01fb\u01fe\3\2\2\2\u01fc\u01fa\3\2\2\2\u01fc\u01fd")
        buf.write("\3\2\2\2\u01fdQ\3\2\2\2\u01fe\u01fc\3\2\2\2\u01ff\u0204")
        buf.write("\5T+\2\u0200\u0201\7C\2\2\u0201\u0203\5T+\2\u0202\u0200")
        buf.write("\3\2\2\2\u0203\u0206\3\2\2\2\u0204\u0202\3\2\2\2\u0204")
        buf.write("\u0205\3\2\2\2\u0205S\3\2\2\2\u0206\u0204\3\2\2\2\u0207")
        buf.write("\u0208\7D\2\2\u0208\u020f\5T+\2\u0209\u020a\7\17\2\2\u020a")
        buf.write("\u020b\5N(\2\u020b\u020c\7\21\2\2\u020c\u020f\3\2\2\2")
        buf.write("\u020d\u020f\5V,\2\u020e\u0207\3\2\2\2\u020e\u0209\3\2")
        buf.write("\2\2\u020e\u020d\3\2\2\2\u020fU\3\2\2\2\u0210\u0214\5")
        buf.write("Z.\2\u0211\u0213\5X-\2\u0212\u0211\3\2\2\2\u0213\u0216")
        buf.write("\3\2\2\2\u0214\u0212\3\2\2\2\u0214\u0215\3\2\2\2\u0215")
        buf.write("W\3\2\2\2\u0216\u0214\3\2\2\2\u0217\u0218\5B\"\2\u0218")
        buf.write("\u0219\5Z.\2\u0219Y\3\2\2\2\u021a\u021b\5\\/\2\u021b[")
        buf.write("\3\2\2\2\u021c\u0221\5^\60\2\u021d\u021e\7E\2\2\u021e")
        buf.write("\u0220\5^\60\2\u021f\u021d\3\2\2\2\u0220\u0223\3\2\2\2")
        buf.write("\u0221\u021f\3\2\2\2\u0221\u0222\3\2\2\2\u0222]\3\2\2")
        buf.write("\2\u0223\u0221\3\2\2\2\u0224\u0229\5`\61\2\u0225\u0226")
        buf.write("\7\23\2\2\u0226\u0228\5`\61\2\u0227\u0225\3\2\2\2\u0228")
        buf.write("\u022b\3\2\2\2\u0229\u0227\3\2\2\2\u0229\u022a\3\2\2\2")
        buf.write("\u022a_\3\2\2\2\u022b\u0229\3\2\2\2\u022c\u0231\5b\62")
        buf.write("\2\u022d\u022e\7\f\2\2\u022e\u0230\5b\62\2\u022f\u022d")
        buf.write("\3\2\2\2\u0230\u0233\3\2\2\2\u0231\u022f\3\2\2\2\u0231")
        buf.write("\u0232\3\2\2\2\u0232a\3\2\2\2\u0233\u0231\3\2\2\2\u0234")
        buf.write("\u0239\5d\63\2\u0235\u0236\7\n\2\2\u0236\u0238\5d\63\2")
        buf.write("\u0237\u0235\3\2\2\2\u0238\u023b\3\2\2\2\u0239\u0237\3")
        buf.write("\2\2\2\u0239\u023a\3\2\2\2\u023ac\3\2\2\2\u023b\u0239")
        buf.write("\3\2\2\2\u023c\u0241\5f\64\2\u023d\u023e\7>\2\2\u023e")
        buf.write("\u0240\5f\64\2\u023f\u023d\3\2\2\2\u0240\u0243\3\2\2\2")
        buf.write("\u0241\u023f\3\2\2\2\u0241\u0242\3\2\2\2\u0242e\3\2\2")
        buf.write("\2\u0243\u0241\3\2\2\2\u0244\u0245\7\23\2\2\u0245\u024f")
        buf.write("\5f\64\2\u0246\u0247\7E\2\2\u0247\u024f\5f\64\2\u0248")
        buf.write("\u0249\7\17\2\2\u0249\u024a\5Z.\2\u024a\u024b\7\21\2\2")
        buf.write("\u024b\u024f\3\2\2\2\u024c\u024f\5h\65\2\u024d\u024f\5")
        buf.write("j\66\2\u024e\u0244\3\2\2\2\u024e\u0246\3\2\2\2\u024e\u0248")
        buf.write("\3\2\2\2\u024e\u024c\3\2\2\2\u024e\u024d\3\2\2\2\u024f")
        buf.write("g\3\2\2\2\u0250\u0251\7H\2\2\u0251\u0252\7\17\2\2\u0252")
        buf.write("\u0257\5Z.\2\u0253\u0254\7\20\2\2\u0254\u0256\5Z.\2\u0255")
        buf.write("\u0253\3\2\2\2\u0256\u0259\3\2\2\2\u0257\u0255\3\2\2\2")
        buf.write("\u0257\u0258\3\2\2\2\u0258\u025a\3\2\2\2\u0259\u0257\3")
        buf.write("\2\2\2\u025a\u025b\7\21\2\2\u025bi\3\2\2\2\u025c\u0261")
        buf.write("\7F\2\2\u025d\u0261\7G\2\2\u025e\u0261\5@!\2\u025f\u0261")
        buf.write("\5H%\2\u0260\u025c\3\2\2\2\u0260\u025d\3\2\2\2\u0260\u025e")
        buf.write("\3\2\2\2\u0260\u025f\3\2\2\2\u0261k\3\2\2\2\u0262\u0263")
        buf.write("\t\f\2\2\u0263m\3\2\2\2\u0264\u0265\7K\2\2\u0265\u0266")
        buf.write("\7\23\2\2\u0266\u0267\7K\2\2\u0267\u0268\7\23\2\2\u0268")
        buf.write("\u0269\7K\2\2\u0269o\3\2\2\2Ltv\u0083\u0086\u0093\u0096")
        buf.write("\u009f\u00a4\u00a8\u00ab\u00b1\u00bb\u00c4\u00c7\u00cf")
        buf.write("\u00d2\u00d7\u00da\u00df\u00e4\u00e6\u00f0\u00f5\u00fa")
        buf.write("\u0103\u0106\u010a\u010d\u0113\u0117\u011a\u0124\u0129")
        buf.write("\u0130\u013b\u0141\u0146\u0151\u0154\u015c\u0161\u016b")
        buf.write("\u016f\u0171\u0183\u018c\u0192\u019c\u01a4\u01a9\u01b2")
        buf.write("\u01b7\u01bd\u01c0\u01c6\u01ca\u01cd\u01de\u01e6\u01ea")
        buf.write("\u01f1\u01f3\u01fc\u0204\u020e\u0214\u0221\u0229\u0231")
        buf.write("\u0239\u0241\u024e\u0257\u0260")
        return buf.getvalue()


class ModelParser(Parser):

    grammarFileName = "Model.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [DFA(ds, i) for i, ds in enumerate(atn.decisionToState)]

    sharedContextCache = PredictionContextCache()

    literalNames = [
        "<INVALID>", "'product'", "'{'", "'}'", "'structure'", "'enumeration'",
        "'behavior'", "'reference'", "'/'", "'..'", "'*'", "'attribute'",
        "'='", "'('", "','", "')'", "'num'", "'-'", "'string'", "'/n'",
        "'define'", "'combinations'", "'explanation'", "'forall'", "'exists'",
        "'condition'", "'valid'", "'start'", "'end'", "'default'", "'imply'",
        "'new'", "'readwrite'", "'readonly'", "'hide'", "'message'", "'debug'",
        "'info'", "'warn'", "'error'", "'explain'", "'require'", "'prefer'",
        "'allow'", "'forbid'", "'-*-'", "';'", "'\u221E'", "'<'", "'<='",
        "'\u2264'", "'>'", "'>='", "'\u2265'", "'=='", "'!='", "'\u2260'",
        "'\u2287'", "'contains'", "'.'", "'^'", "'['", "']'", "'last'", "'||'",
        "'&&'", "'!'", "'+'", "'true'", "'false'"
    ]

    symbolicNames = [
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>",
        "FUNCTION", "KEYWORD", "NAME", "INTEGER", "FLOATING", "TIMES",
        "HASHES", "NEWLINE", "WHITESPACE", "COMMENT", "MULTILINE_COMMENT"
    ]

    RULE_root = 0
    RULE_product = 1
    RULE_structure = 2
    RULE_enumeration = 3
    RULE_behavior = 4
    RULE_behavior_block = 5
    RULE_feature = 6
    RULE_cardinality = 7
    RULE_attribute = 8
    RULE_option = 9
    RULE_field = 10
    RULE_number_def = 11
    RULE_string_def = 12
    RULE_define = 13
    RULE_conditioned = 14
    RULE_combinations = 15
    RULE_explanation = 16
    RULE_index_quantification = 17
    RULE_precondition = 18
    RULE_assign_default = 19
    RULE_assign_imply = 20
    RULE_assign_new = 21
    RULE_interaction = 22
    RULE_message = 23
    RULE_require = 24
    RULE_prefer = 25
    RULE_combination_row = 26
    RULE_combination_item = 27
    RULE_combination_atom = 28
    RULE_stmt_end = 29
    RULE_constant = 30
    RULE_floating = 31
    RULE_compare = 32
    RULE_unit = 33
    RULE_fraction = 34
    RULE_path = 35
    RULE_path_item = 36
    RULE_path_index = 37
    RULE_condition = 38
    RULE_condition_or = 39
    RULE_condition_and = 40
    RULE_condition_not = 41
    RULE_condition_compare = 42
    RULE_condition_part = 43
    RULE_formula = 44
    RULE_formula_add = 45
    RULE_formula_sub = 46
    RULE_formula_mul = 47
    RULE_formula_div = 48
    RULE_formula_pow = 49
    RULE_formula_sign = 50
    RULE_formula_func = 51
    RULE_formula_atom = 52
    RULE_name = 53
    RULE_date = 54

    ruleNames = [
        "root", "product", "structure", "enumeration", "behavior",
        "behavior_block", "feature", "cardinality", "attribute", "option",
        "field", "number_def", "string_def", "define", "conditioned",
        "combinations", "explanation", "index_quantification", "precondition",
        "assign_default", "assign_imply", "assign_new", "interaction",
        "message", "require", "prefer", "combination_row", "combination_item",
        "combination_atom", "stmt_end", "constant", "floating", "compare",
        "unit", "fraction", "path", "path_item", "path_index", "condition",
        "condition_or", "condition_and", "condition_not", "condition_compare",
        "condition_part", "formula", "formula_add", "formula_sub",
        "formula_mul", "formula_div", "formula_pow", "formula_sign",
        "formula_func", "formula_atom", "name", "date"
    ]

    EOF = Token.EOF
    T__0 = 1
    T__1 = 2
    T__2 = 3
    T__3 = 4
    T__4 = 5
    T__5 = 6
    T__6 = 7
    T__7 = 8
    T__8 = 9
    T__9 = 10
    T__10 = 11
    T__11 = 12
    T__12 = 13
    T__13 = 14
    T__14 = 15
    T__15 = 16
    T__16 = 17
    T__17 = 18
    T__18 = 19
    T__19 = 20
    T__20 = 21
    T__21 = 22
    T__22 = 23
    T__23 = 24
    T__24 = 25
    T__25 = 26
    T__26 = 27
    T__27 = 28
    T__28 = 29
    T__29 = 30
    T__30 = 31
    T__31 = 32
    T__32 = 33
    T__33 = 34
    T__34 = 35
    T__35 = 36
    T__36 = 37
    T__37 = 38
    T__38 = 39
    T__39 = 40
    T__40 = 41
    T__41 = 42
    T__42 = 43
    T__43 = 44
    T__44 = 45
    T__45 = 46
    T__46 = 47
    T__47 = 48
    T__48 = 49
    T__49 = 50
    T__50 = 51
    T__51 = 52
    T__52 = 53
    T__53 = 54
    T__54 = 55
    T__55 = 56
    T__56 = 57
    T__57 = 58
    T__58 = 59
    T__59 = 60
    T__60 = 61
    T__61 = 62
    T__62 = 63
    T__63 = 64
    T__64 = 65
    T__65 = 66
    T__66 = 67
    T__67 = 68
    T__68 = 69
    FUNCTION = 70
    KEYWORD = 71
    NAME = 72
    INTEGER = 73
    FLOATING = 74
    TIMES = 75
    HASHES = 76
    NEWLINE = 77
    WHITESPACE = 78
    COMMENT = 79
    MULTILINE_COMMENT = 80

    def __init__(self, input: TokenStream, output: TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA,
                                          self.sharedContextCache)
        self._predicates = None

    def wasNewline(self):
        for index in reversed(range(self.getCurrentToken().tokenIndex)):
            # stop on default channel
            token = self.getTokenStream().get(index)
            if token.channel == 0:
                break

            # if the token is blank and contains newline, we found it
            if len(token.text) == 0:
                continue
            if token.text.startswith("\n") or token.text.startswith("\r"):
                return True

        return False

    class RootContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(ModelParser.EOF, 0)

        def product(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.ProductContext)
            else:
                return self.getTypedRuleContext(ModelParser.ProductContext, i)

        def structure(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.StructureContext)
            else:
                return self.getTypedRuleContext(ModelParser.StructureContext,
                                                i)

        def enumeration(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.EnumerationContext)
            else:
                return self.getTypedRuleContext(ModelParser.EnumerationContext,
                                                i)

        def behavior(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.BehaviorContext)
            else:
                return self.getTypedRuleContext(ModelParser.BehaviorContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_root

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRoot"):
                listener.enterRoot(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRoot"):
                listener.exitRoot(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRoot"):
                return visitor.visitRoot(self)
            else:
                return visitor.visitChildren(self)

    def root(self):

        localctx = ModelParser.RootContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_root)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 116
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and
                   ((1 << _la) &
                    ((1 << ModelParser.T__0) | (1 << ModelParser.T__3) |
                     (1 << ModelParser.T__4) | (1 << ModelParser.T__5))) != 0):
                self.state = 114
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ModelParser.T__0]:
                    self.state = 110
                    self.product()
                    pass
                elif token in [ModelParser.T__3]:
                    self.state = 111
                    self.structure()
                    pass
                elif token in [ModelParser.T__4]:
                    self.state = 112
                    self.enumeration()
                    pass
                elif token in [ModelParser.T__5]:
                    self.state = 113
                    self.behavior()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 118
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 119
            self.match(ModelParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ProductContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def feature(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.FeatureContext)
            else:
                return self.getTypedRuleContext(ModelParser.FeatureContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_product

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterProduct"):
                listener.enterProduct(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitProduct"):
                listener.exitProduct(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitProduct"):
                return visitor.visitProduct(self)
            else:
                return visitor.visitChildren(self)

    def product(self):

        localctx = ModelParser.ProductContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_product)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 121
            self.match(ModelParser.T__0)
            self.state = 122
            self.match(ModelParser.T__1)
            self.state = 132
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and
                ((1 << _la) &
                 ((1 << ModelParser.T__6) | (1 << ModelParser.T__15) |
                  (1 << ModelParser.T__17))) != 0) or (
                      (((_la - 70)) & ~0x3f) == 0 and
                      ((1 <<
                        (_la - 70)) & ((1 << (ModelParser.FUNCTION - 70)) |
                                       (1 << (ModelParser.KEYWORD - 70)) |
                                       (1 << (ModelParser.NAME - 70)) |
                                       (1 << (ModelParser.INTEGER - 70)) |
                                       (1 << (ModelParser.TIMES - 70)))) != 0):
                self.state = 123
                self.feature()
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and
                       ((1 << _la) &
                        ((1 << ModelParser.T__6) | (1 << ModelParser.T__15) |
                         (1 << ModelParser.T__17) |
                         (1 << ModelParser.T__45))) != 0) or (
                             (((_la - 70)) & ~0x3f) == 0 and
                             ((1 << (_la - 70)) &
                              ((1 << (ModelParser.FUNCTION - 70)) |
                               (1 << (ModelParser.KEYWORD - 70)) |
                               (1 << (ModelParser.NAME - 70)) |
                               (1 << (ModelParser.INTEGER - 70)) |
                               (1 << (ModelParser.TIMES - 70)))) != 0):
                    self.state = 124
                    self.stmt_end()
                    self.state = 125
                    self.feature()
                    self.state = 131
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 134
            self.match(ModelParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class StructureContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def feature(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.FeatureContext)
            else:
                return self.getTypedRuleContext(ModelParser.FeatureContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_structure

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStructure"):
                listener.enterStructure(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStructure"):
                listener.exitStructure(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStructure"):
                return visitor.visitStructure(self)
            else:
                return visitor.visitChildren(self)

    def structure(self):

        localctx = ModelParser.StructureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_structure)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 136
            self.match(ModelParser.T__3)
            self.state = 137
            self.name()
            self.state = 138
            self.match(ModelParser.T__1)
            self.state = 148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and
                ((1 << _la) &
                 ((1 << ModelParser.T__6) | (1 << ModelParser.T__15) |
                  (1 << ModelParser.T__17))) != 0) or (
                      (((_la - 70)) & ~0x3f) == 0 and
                      ((1 <<
                        (_la - 70)) & ((1 << (ModelParser.FUNCTION - 70)) |
                                       (1 << (ModelParser.KEYWORD - 70)) |
                                       (1 << (ModelParser.NAME - 70)) |
                                       (1 << (ModelParser.INTEGER - 70)) |
                                       (1 << (ModelParser.TIMES - 70)))) != 0):
                self.state = 139
                self.feature()
                self.state = 145
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and
                       ((1 << _la) &
                        ((1 << ModelParser.T__6) | (1 << ModelParser.T__15) |
                         (1 << ModelParser.T__17) |
                         (1 << ModelParser.T__45))) != 0) or (
                             (((_la - 70)) & ~0x3f) == 0 and
                             ((1 << (_la - 70)) &
                              ((1 << (ModelParser.FUNCTION - 70)) |
                               (1 << (ModelParser.KEYWORD - 70)) |
                               (1 << (ModelParser.NAME - 70)) |
                               (1 << (ModelParser.INTEGER - 70)) |
                               (1 << (ModelParser.TIMES - 70)))) != 0):
                    self.state = 140
                    self.stmt_end()
                    self.state = 141
                    self.feature()
                    self.state = 147
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 150
            self.match(ModelParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnumerationContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def attribute(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.AttributeContext)
            else:
                return self.getTypedRuleContext(ModelParser.AttributeContext,
                                                i)

        def option(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.OptionContext)
            else:
                return self.getTypedRuleContext(ModelParser.OptionContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_enumeration

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterEnumeration"):
                listener.enterEnumeration(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitEnumeration"):
                listener.exitEnumeration(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitEnumeration"):
                return visitor.visitEnumeration(self)
            else:
                return visitor.visitChildren(self)

    def enumeration(self):

        localctx = ModelParser.EnumerationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_enumeration)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(ModelParser.T__4)
            self.state = 153
            self.name()
            self.state = 154
            self.match(ModelParser.T__1)
            self.state = 169
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 11)) & ~0x3f) == 0
                    and ((1 <<
                          (_la - 11)) & ((1 << (ModelParser.T__10 - 11)) |
                                         (1 << (ModelParser.FUNCTION - 11)) |
                                         (1 << (ModelParser.KEYWORD - 11)) |
                                         (1 <<
                                          (ModelParser.NAME - 11)))) != 0):
                self.state = 157
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ModelParser.T__10]:
                    self.state = 155
                    self.attribute()
                    pass
                elif token in [
                        ModelParser.FUNCTION, ModelParser.KEYWORD,
                        ModelParser.NAME
                ]:
                    self.state = 156
                    self.option()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 166
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 11)) & ~0x3f) == 0
                       and ((1 <<
                             (_la - 11)) & ((1 << (ModelParser.T__10 - 11)) |
                                            (1 << (ModelParser.T__45 - 11)) |
                                            (1 <<
                                             (ModelParser.FUNCTION - 11)) |
                                            (1 << (ModelParser.KEYWORD - 11)) |
                                            (1 <<
                                             (ModelParser.NAME - 11)))) != 0):
                    self.state = 159
                    self.stmt_end()
                    self.state = 162
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [ModelParser.T__10]:
                        self.state = 160
                        self.attribute()
                        pass
                    elif token in [
                            ModelParser.FUNCTION, ModelParser.KEYWORD,
                            ModelParser.NAME
                    ]:
                        self.state = 161
                        self.option()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 168
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 171
            self.match(ModelParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BehaviorContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def behavior_block(self):
            return self.getTypedRuleContext(ModelParser.Behavior_blockContext,
                                            0)

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_behavior

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBehavior"):
                listener.enterBehavior(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBehavior"):
                listener.exitBehavior(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBehavior"):
                return visitor.visitBehavior(self)
            else:
                return visitor.visitChildren(self)

    def behavior(self):

        localctx = ModelParser.BehaviorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_behavior)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(ModelParser.T__5)
            self.state = 175
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 70)) & ~0x3f) == 0
                    and ((1 <<
                          (_la - 70)) & ((1 << (ModelParser.FUNCTION - 70)) |
                                         (1 << (ModelParser.KEYWORD - 70)) |
                                         (1 <<
                                          (ModelParser.NAME - 70)))) != 0):
                self.state = 174
                self.name()

            self.state = 177
            self.behavior_block()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Behavior_blockContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def define(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.DefineContext)
            else:
                return self.getTypedRuleContext(ModelParser.DefineContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def message(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.MessageContext)
            else:
                return self.getTypedRuleContext(ModelParser.MessageContext, i)

        def conditioned(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.ConditionedContext)
            else:
                return self.getTypedRuleContext(ModelParser.ConditionedContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_behavior_block

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterBehavior_block"):
                listener.enterBehavior_block(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitBehavior_block"):
                listener.exitBehavior_block(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitBehavior_block"):
                return visitor.visitBehavior_block(self)
            else:
                return visitor.visitChildren(self)

    def behavior_block(self):

        localctx = ModelParser.Behavior_blockContext(self, self._ctx,
                                                     self.state)
        self.enterRule(localctx, 10, self.RULE_behavior_block)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            self.match(ModelParser.T__1)
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__19:
                self.state = 180
                self.define()
                self.state = 181
                self.stmt_end()
                self.state = 187
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 13, self._ctx)
            if la_ == 1:
                self.state = 188
                self.message()
                self.state = 194
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 12, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 189
                        self.stmt_end()
                        self.state = 190
                        self.message()
                    self.state = 196
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(
                        self._input, 12, self._ctx)

            self.state = 208
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0
                    and ((1 << _la) &
                         ((1 << ModelParser.T__1) | (1 << ModelParser.T__20) |
                          (1 << ModelParser.T__21) | (1 << ModelParser.T__22) |
                          (1 << ModelParser.T__23) | (1 << ModelParser.T__24) |
                          (1 << ModelParser.T__25) | (1 << ModelParser.T__28) |
                          (1 << ModelParser.T__29) | (1 << ModelParser.T__30) |
                          (1 << ModelParser.T__31) | (1 << ModelParser.T__32) |
                          (1 << ModelParser.T__33) | (1 << ModelParser.T__40) |
                          (1 << ModelParser.T__41))) != 0):
                self.state = 199
                self.conditioned()
                self.state = 205
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and
                       ((1 << _la) &
                        ((1 << ModelParser.T__1) | (1 << ModelParser.T__20) |
                         (1 << ModelParser.T__21) | (1 << ModelParser.T__22) |
                         (1 << ModelParser.T__23) | (1 << ModelParser.T__24) |
                         (1 << ModelParser.T__25) | (1 << ModelParser.T__28) |
                         (1 << ModelParser.T__29) | (1 << ModelParser.T__30) |
                         (1 << ModelParser.T__31) | (1 << ModelParser.T__32) |
                         (1 << ModelParser.T__33) | (1 << ModelParser.T__40) |
                         (1 << ModelParser.T__41) |
                         (1 << ModelParser.T__45))) != 0):
                    self.state = 200
                    self.stmt_end()
                    self.state = 201
                    self.conditioned()
                    self.state = 207
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

            self.state = 210
            self.match(ModelParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FeatureContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ref = None  # Token
            self.priority = None  # Token

        def field(self):
            return self.getTypedRuleContext(ModelParser.FieldContext, 0)

        def cardinality(self):
            return self.getTypedRuleContext(ModelParser.CardinalityContext, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_feature

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFeature"):
                listener.enterFeature(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFeature"):
                listener.exitFeature(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFeature"):
                return visitor.visitFeature(self)
            else:
                return visitor.visitChildren(self)

    def feature(self):

        localctx = ModelParser.FeatureContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_feature)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__6:
                self.state = 212
                localctx.ref = self.match(ModelParser.T__6)

            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.INTEGER or _la == ModelParser.TIMES:
                self.state = 215
                self.cardinality()

            self.state = 218
            self.field()
            self.state = 221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__7:
                self.state = 219
                self.match(ModelParser.T__7)
                self.state = 220
                localctx.priority = self.match(ModelParser.INTEGER)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CardinalityContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.min = None  # Token
            self.range = None  # Token
            self.max = None  # Token

        def INTEGER(self, i: int = None):
            if i is None:
                return self.getTokens(ModelParser.INTEGER)
            else:
                return self.getToken(ModelParser.INTEGER, i)

        def TIMES(self, i: int = None):
            if i is None:
                return self.getTokens(ModelParser.TIMES)
            else:
                return self.getToken(ModelParser.TIMES, i)

        def getRuleIndex(self):
            return ModelParser.RULE_cardinality

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCardinality"):
                listener.enterCardinality(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCardinality"):
                listener.exitCardinality(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCardinality"):
                return visitor.visitCardinality(self)
            else:
                return visitor.visitChildren(self)

    def cardinality(self):

        localctx = ModelParser.CardinalityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_cardinality)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 223
            localctx.min = self._input.LT(1)
            _la = self._input.LA(1)
            if not (_la == ModelParser.INTEGER or _la == ModelParser.TIMES):
                localctx.min = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 228
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__8:
                self.state = 224
                localctx.range = self.match(ModelParser.T__8)
                self.state = 226
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__9 or _la == ModelParser.INTEGER or _la == ModelParser.TIMES:
                    self.state = 225
                    localctx.max = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not (_la == ModelParser.T__9
                            or _la == ModelParser.INTEGER
                            or _la == ModelParser.TIMES):
                        localctx.max = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AttributeContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def field(self):
            return self.getTypedRuleContext(ModelParser.FieldContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_attribute

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAttribute"):
                listener.enterAttribute(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAttribute"):
                listener.exitAttribute(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAttribute"):
                return visitor.visitAttribute(self)
            else:
                return visitor.visitChildren(self)

    def attribute(self):

        localctx = ModelParser.AttributeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_attribute)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 230
            self.match(ModelParser.T__10)
            self.state = 231
            self.field()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class OptionContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def constant(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.ConstantContext)
            else:
                return self.getTypedRuleContext(ModelParser.ConstantContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_option

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterOption"):
                listener.enterOption(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitOption"):
                listener.exitOption(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitOption"):
                return visitor.visitOption(self)
            else:
                return visitor.visitChildren(self)

    def option(self):

        localctx = ModelParser.OptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_option)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 233
            self.name()
            self.state = 248
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__11:
                self.state = 234
                self.match(ModelParser.T__11)
                self.state = 235
                self.match(ModelParser.T__12)
                self.state = 236
                self.constant()
                self.state = 243
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while ((((_la - 14)) & ~0x3f) == 0
                       and ((1 << (_la - 14)) &
                            ((1 << (ModelParser.T__13 - 14)) |
                             (1 << (ModelParser.T__16 - 14)) |
                             (1 << (ModelParser.T__46 - 14)) |
                             (1 << (ModelParser.FUNCTION - 14)) |
                             (1 << (ModelParser.KEYWORD - 14)) |
                             (1 << (ModelParser.NAME - 14)) |
                             (1 << (ModelParser.INTEGER - 14)) |
                             (1 << (ModelParser.FLOATING - 14)))) != 0):
                    self.state = 238
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ModelParser.T__13:
                        self.state = 237
                        self.match(ModelParser.T__13)

                    self.state = 240
                    self.constant()
                    self.state = 245
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 246
                self.match(ModelParser.T__14)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FieldContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.fieldName = None  # NameContext
            self.type_ref = None  # NameContext

        def number_def(self):
            return self.getTypedRuleContext(ModelParser.Number_defContext, 0)

        def name(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.NameContext)
            else:
                return self.getTypedRuleContext(ModelParser.NameContext, i)

        def string_def(self):
            return self.getTypedRuleContext(ModelParser.String_defContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_field

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterField"):
                listener.enterField(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitField"):
                listener.exitField(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitField"):
                return visitor.visitField(self)
            else:
                return visitor.visitChildren(self)

    def field(self):

        localctx = ModelParser.FieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_field)
        try:
            self.state = 260
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ModelParser.T__15]:
                self.enterOuterAlt(localctx, 1)
                self.state = 250
                self.number_def()
                self.state = 251
                localctx.fieldName = self.name()
                pass
            elif token in [ModelParser.T__17]:
                self.enterOuterAlt(localctx, 2)
                self.state = 253
                self.string_def()
                self.state = 254
                localctx.fieldName = self.name()
                pass
            elif token in [
                    ModelParser.FUNCTION, ModelParser.KEYWORD, ModelParser.NAME
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 257
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input, 24, self._ctx)
                if la_ == 1:
                    self.state = 256
                    localctx.type_ref = self.name()

                self.state = 259
                localctx.fieldName = self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Number_defContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.min = None  # FloatingContext
            self.max = None  # FloatingContext

        def fraction(self):
            return self.getTypedRuleContext(ModelParser.FractionContext, 0)

        def unit(self):
            return self.getTypedRuleContext(ModelParser.UnitContext, 0)

        def floating(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.FloatingContext)
            else:
                return self.getTypedRuleContext(ModelParser.FloatingContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_number_def

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterNumber_def"):
                listener.enterNumber_def(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitNumber_def"):
                listener.exitNumber_def(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitNumber_def"):
                return visitor.visitNumber_def(self)
            else:
                return visitor.visitChildren(self)

    def number_def(self):

        localctx = ModelParser.Number_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_number_def)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 262
            self.match(ModelParser.T__15)
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__58 or _la == ModelParser.T__59:
                self.state = 263
                self.fraction()

            self.state = 267
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__7:
                self.state = 266
                self.unit()

            self.state = 273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 17)) & ~0x3f) == 0
                    and ((1 <<
                          (_la - 17)) & ((1 << (ModelParser.T__16 - 17)) |
                                         (1 << (ModelParser.T__46 - 17)) |
                                         (1 << (ModelParser.INTEGER - 17)) |
                                         (1 <<
                                          (ModelParser.FLOATING - 17)))) != 0):
                self.state = 269
                localctx.min = self.floating()
                self.state = 270
                self.match(ModelParser.T__16)
                self.state = 271
                localctx.max = self.floating()

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_defContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.multiLine = None  # Token
            self.maxLength = None  # Token

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_string_def

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterString_def"):
                listener.enterString_def(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitString_def"):
                listener.exitString_def(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitString_def"):
                return visitor.visitString_def(self)
            else:
                return visitor.visitChildren(self)

    def string_def(self):

        localctx = ModelParser.String_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_string_def)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(ModelParser.T__17)
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__18:
                self.state = 276
                localctx.multiLine = self.match(ModelParser.T__18)

            self.state = 280
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.INTEGER:
                self.state = 279
                localctx.maxLength = self.match(ModelParser.INTEGER)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DefineContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_define

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDefine"):
                listener.enterDefine(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDefine"):
                listener.exitDefine(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDefine"):
                return visitor.visitDefine(self)
            else:
                return visitor.visitChildren(self)

    def define(self):

        localctx = ModelParser.DefineContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_define)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.match(ModelParser.T__19)
            self.state = 283
            self.name()
            self.state = 284
            self.match(ModelParser.T__11)
            self.state = 285
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionedContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def behavior_block(self):
            return self.getTypedRuleContext(ModelParser.Behavior_blockContext,
                                            0)

        def assign_default(self):
            return self.getTypedRuleContext(ModelParser.Assign_defaultContext,
                                            0)

        def assign_imply(self):
            return self.getTypedRuleContext(ModelParser.Assign_implyContext, 0)

        def assign_new(self):
            return self.getTypedRuleContext(ModelParser.Assign_newContext, 0)

        def interaction(self):
            return self.getTypedRuleContext(ModelParser.InteractionContext, 0)

        def require(self):
            return self.getTypedRuleContext(ModelParser.RequireContext, 0)

        def prefer(self):
            return self.getTypedRuleContext(ModelParser.PreferContext, 0)

        def combinations(self):
            return self.getTypedRuleContext(ModelParser.CombinationsContext, 0)

        def explanation(self):
            return self.getTypedRuleContext(ModelParser.ExplanationContext, 0)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def index_quantification(self):
            return self.getTypedRuleContext(
                ModelParser.Index_quantificationContext, 0)

        def precondition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.PreconditionContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.PreconditionContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_conditioned

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConditioned"):
                listener.enterConditioned(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConditioned"):
                listener.exitConditioned(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConditioned"):
                return visitor.visitConditioned(self)
            else:
                return visitor.visitChildren(self)

    def conditioned(self):

        localctx = ModelParser.ConditionedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_conditioned)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__21:
                self.state = 287
                self.explanation()
                self.state = 288
                self.stmt_end()

            self.state = 295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__22 or _la == ModelParser.T__23:
                self.state = 292
                self.index_quantification()
                self.state = 293
                self.stmt_end()

            self.state = 302
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__24 or _la == ModelParser.T__25:
                self.state = 297
                self.precondition()
                self.state = 298
                self.stmt_end()
                self.state = 304
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 313
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ModelParser.T__1]:
                self.state = 305
                self.behavior_block()
                pass
            elif token in [ModelParser.T__28]:
                self.state = 306
                self.assign_default()
                pass
            elif token in [ModelParser.T__29]:
                self.state = 307
                self.assign_imply()
                pass
            elif token in [ModelParser.T__30]:
                self.state = 308
                self.assign_new()
                pass
            elif token in [
                    ModelParser.T__31, ModelParser.T__32, ModelParser.T__33
            ]:
                self.state = 309
                self.interaction()
                pass
            elif token in [ModelParser.T__40]:
                self.state = 310
                self.require()
                pass
            elif token in [ModelParser.T__41]:
                self.state = 311
                self.prefer()
                pass
            elif token in [ModelParser.T__20]:
                self.state = 312
                self.combinations()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CombinationsContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formula(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.FormulaContext)
            else:
                return self.getTypedRuleContext(ModelParser.FormulaContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def combination_row(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Combination_rowContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Combination_rowContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_combinations

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCombinations"):
                listener.enterCombinations(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCombinations"):
                listener.exitCombinations(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCombinations"):
                return visitor.visitCombinations(self)
            else:
                return visitor.visitChildren(self)

    def combinations(self):

        localctx = ModelParser.CombinationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_combinations)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 315
            self.match(ModelParser.T__20)
            self.state = 316
            self.match(ModelParser.T__12)
            self.state = 317
            self.formula()
            self.state = 324
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 13)) & ~0x3f) == 0 and
                   ((1 << (_la - 13)) &
                    ((1 << (ModelParser.T__12 - 13)) |
                     (1 <<
                      (ModelParser.T__13 - 13)) | (1 <<
                                                   (ModelParser.T__16 - 13)) |
                     (1 <<
                      (ModelParser.T__46 - 13)) | (1 <<
                                                   (ModelParser.T__66 - 13)) |
                     (1 <<
                      (ModelParser.T__67 - 13)) | (1 <<
                                                   (ModelParser.T__68 - 13)) |
                     (1 << (ModelParser.FUNCTION - 13)) |
                     (1 << (ModelParser.KEYWORD - 13)) |
                     (1 <<
                      (ModelParser.NAME - 13)) | (1 <<
                                                  (ModelParser.INTEGER - 13)) |
                     (1 << (ModelParser.FLOATING - 13)))) != 0):
                self.state = 319
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__13:
                    self.state = 318
                    self.match(ModelParser.T__13)

                self.state = 321
                self.formula()
                self.state = 326
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 327
            self.match(ModelParser.T__14)
            self.state = 328
            self.stmt_end()
            self.state = 338
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__42 or _la == ModelParser.T__43:
                self.state = 329
                self.combination_row()
                self.state = 335
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 37, self._ctx)
                while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 330
                        self.stmt_end()
                        self.state = 331
                        self.combination_row()
                    self.state = 337
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(
                        self._input, 37, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ExplanationContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_explanation

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterExplanation"):
                listener.enterExplanation(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitExplanation"):
                listener.exitExplanation(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitExplanation"):
                return visitor.visitExplanation(self)
            else:
                return visitor.visitChildren(self)

    def explanation(self):

        localctx = ModelParser.ExplanationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_explanation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 340
            self.match(ModelParser.T__21)
            self.state = 341
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Index_quantificationContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.index_variable = None  # Token

        def NAME(self, i: int = None):
            if i is None:
                return self.getTokens(ModelParser.NAME)
            else:
                return self.getToken(ModelParser.NAME, i)

        def getRuleIndex(self):
            return ModelParser.RULE_index_quantification

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterIndex_quantification"):
                listener.enterIndex_quantification(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitIndex_quantification"):
                listener.exitIndex_quantification(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitIndex_quantification"):
                return visitor.visitIndex_quantification(self)
            else:
                return visitor.visitChildren(self)

    def index_quantification(self):

        localctx = ModelParser.Index_quantificationContext(
            self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_index_quantification)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 343
            _la = self._input.LA(1)
            if not (_la == ModelParser.T__22 or _la == ModelParser.T__23):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 344
            localctx.index_variable = self.match(ModelParser.NAME)
            self.state = 351
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__13 or _la == ModelParser.NAME:
                self.state = 346
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__13:
                    self.state = 345
                    self.match(ModelParser.T__13)

                self.state = 348
                localctx.index_variable = self.match(ModelParser.NAME)
                self.state = 353
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreconditionContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.start = None  # DateContext
            self.end = None  # DateContext

        def condition(self):
            return self.getTypedRuleContext(ModelParser.ConditionContext, 0)

        def date(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.DateContext)
            else:
                return self.getTypedRuleContext(ModelParser.DateContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_precondition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrecondition"):
                listener.enterPrecondition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrecondition"):
                listener.exitPrecondition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrecondition"):
                return visitor.visitPrecondition(self)
            else:
                return visitor.visitChildren(self)

    def precondition(self):

        localctx = ModelParser.PreconditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_precondition)
        self._la = 0  # Token type
        try:
            self.state = 367
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ModelParser.T__24]:
                self.enterOuterAlt(localctx, 1)
                self.state = 354
                self.match(ModelParser.T__24)
                self.state = 355
                self.condition()
                pass
            elif token in [ModelParser.T__25]:
                self.enterOuterAlt(localctx, 2)
                self.state = 356
                self.match(ModelParser.T__25)
                self.state = 365
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [ModelParser.T__26]:
                    self.state = 357
                    self.match(ModelParser.T__26)
                    self.state = 358
                    localctx.start = self.date()
                    self.state = 361
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ModelParser.T__27:
                        self.state = 359
                        self.match(ModelParser.T__27)
                        self.state = 360
                        localctx.end = self.date()

                    pass
                elif token in [ModelParser.T__27]:
                    self.state = 363
                    self.match(ModelParser.T__27)
                    self.state = 364
                    localctx.end = self.date()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assign_defaultContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path(self):
            return self.getTypedRuleContext(ModelParser.PathContext, 0)

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_assign_default

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssign_default"):
                listener.enterAssign_default(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssign_default"):
                listener.exitAssign_default(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssign_default"):
                return visitor.visitAssign_default(self)
            else:
                return visitor.visitChildren(self)

    def assign_default(self):

        localctx = ModelParser.Assign_defaultContext(self, self._ctx,
                                                     self.state)
        self.enterRule(localctx, 38, self.RULE_assign_default)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 369
            self.match(ModelParser.T__28)
            self.state = 370
            self.path()
            self.state = 371
            self.match(ModelParser.T__11)
            self.state = 372
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assign_implyContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path(self):
            return self.getTypedRuleContext(ModelParser.PathContext, 0)

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_assign_imply

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssign_imply"):
                listener.enterAssign_imply(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssign_imply"):
                listener.exitAssign_imply(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssign_imply"):
                return visitor.visitAssign_imply(self)
            else:
                return visitor.visitChildren(self)

    def assign_imply(self):

        localctx = ModelParser.Assign_implyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_assign_imply)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 374
            self.match(ModelParser.T__29)
            self.state = 375
            self.path()
            self.state = 376
            self.match(ModelParser.T__11)
            self.state = 377
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assign_newContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path(self):
            return self.getTypedRuleContext(ModelParser.PathContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_assign_new

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterAssign_new"):
                listener.enterAssign_new(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitAssign_new"):
                listener.exitAssign_new(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitAssign_new"):
                return visitor.visitAssign_new(self)
            else:
                return visitor.visitChildren(self)

    def assign_new(self):

        localctx = ModelParser.Assign_newContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_assign_new)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 379
            self.match(ModelParser.T__30)
            self.state = 380
            self.path()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class InteractionContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.directive = None  # Token
            self.priority = None  # Token

        def path(self):
            return self.getTypedRuleContext(ModelParser.PathContext, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_interaction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterInteraction"):
                listener.enterInteraction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitInteraction"):
                listener.exitInteraction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitInteraction"):
                return visitor.visitInteraction(self)
            else:
                return visitor.visitChildren(self)

    def interaction(self):

        localctx = ModelParser.InteractionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_interaction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 382
            localctx.directive = self._input.LT(1)
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and
                     ((1 << _la) &
                      ((1 << ModelParser.T__31) | (1 << ModelParser.T__32) |
                       (1 << ModelParser.T__33))) != 0)):
                localctx.directive = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 385
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__7:
                self.state = 383
                self.match(ModelParser.T__7)
                self.state = 384
                localctx.priority = self.match(ModelParser.INTEGER)

            self.state = 387
            self.path()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class MessageContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.level = None  # Token

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def precondition(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.PreconditionContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.PreconditionContext, i)

        def stmt_end(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Stmt_endContext)
            else:
                return self.getTypedRuleContext(ModelParser.Stmt_endContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_message

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterMessage"):
                listener.enterMessage(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitMessage"):
                listener.exitMessage(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitMessage"):
                return visitor.visitMessage(self)
            else:
                return visitor.visitChildren(self)

    def message(self):

        localctx = ModelParser.MessageContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_message)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 394
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__24 or _la == ModelParser.T__25:
                self.state = 389
                self.precondition()
                self.state = 390
                self.stmt_end()
                self.state = 396
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 397
            self.match(ModelParser.T__34)
            self.state = 400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__7:
                self.state = 398
                self.match(ModelParser.T__7)
                self.state = 399
                localctx.level = self._input.LT(1)
                _la = self._input.LA(1)
                if not ((((_la) & ~0x3f) == 0 and
                         ((1 << _la) & ((1 << ModelParser.T__35) |
                                        (1 << ModelParser.T__36) |
                                        (1 << ModelParser.T__37) |
                                        (1 << ModelParser.T__38) |
                                        (1 << ModelParser.T__39))) != 0)):
                    localctx.level = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()

            self.state = 402
            self.name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class RequireContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition(self):
            return self.getTypedRuleContext(ModelParser.ConditionContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_require

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterRequire"):
                listener.enterRequire(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitRequire"):
                listener.exitRequire(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitRequire"):
                return visitor.visitRequire(self)
            else:
                return visitor.visitChildren(self)

    def require(self):

        localctx = ModelParser.RequireContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_require)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 404
            self.match(ModelParser.T__40)
            self.state = 405
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PreferContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.penalty = None  # Token

        def condition(self):
            return self.getTypedRuleContext(ModelParser.ConditionContext, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_prefer

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPrefer"):
                listener.enterPrefer(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPrefer"):
                listener.exitPrefer(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPrefer"):
                return visitor.visitPrefer(self)
            else:
                return visitor.visitChildren(self)

    def prefer(self):

        localctx = ModelParser.PreferContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_prefer)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 407
            self.match(ModelParser.T__41)
            self.state = 410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__7:
                self.state = 408
                self.match(ModelParser.T__7)
                self.state = 409
                localctx.penalty = self.match(ModelParser.INTEGER)

            self.state = 412
            self.condition()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Combination_rowContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.rowType = None  # Token

        def combination_item(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Combination_itemContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Combination_itemContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_combination_row

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCombination_row"):
                listener.enterCombination_row(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCombination_row"):
                listener.exitCombination_row(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCombination_row"):
                return visitor.visitCombination_row(self)
            else:
                return visitor.visitChildren(self)

    def combination_row(self):

        localctx = ModelParser.Combination_rowContext(self, self._ctx,
                                                      self.state)
        self.enterRule(localctx, 52, self.RULE_combination_row)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 414
            localctx.rowType = self._input.LT(1)
            _la = self._input.LA(1)
            if not (_la == ModelParser.T__42 or _la == ModelParser.T__43):
                localctx.rowType = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 415
            self.match(ModelParser.T__12)
            self.state = 416
            self.combination_item()
            self.state = 423
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 12)) & ~0x3f) == 0 and
                   ((1 << (_la - 12)) &
                    ((1 <<
                      (ModelParser.T__11 - 12)) | (1 <<
                                                   (ModelParser.T__12 - 12)) |
                     (1 <<
                      (ModelParser.T__13 - 12)) | (1 <<
                                                   (ModelParser.T__16 - 12)) |
                     (1 <<
                      (ModelParser.T__44 - 12)) | (1 <<
                                                   (ModelParser.T__46 - 12)) |
                     (1 <<
                      (ModelParser.T__47 - 12)) | (1 <<
                                                   (ModelParser.T__48 - 12)) |
                     (1 <<
                      (ModelParser.T__49 - 12)) | (1 <<
                                                   (ModelParser.T__50 - 12)) |
                     (1 <<
                      (ModelParser.T__51 - 12)) | (1 <<
                                                   (ModelParser.T__52 - 12)) |
                     (1 <<
                      (ModelParser.T__53 - 12)) | (1 <<
                                                   (ModelParser.T__54 - 12)) |
                     (1 <<
                      (ModelParser.T__55 - 12)) | (1 <<
                                                   (ModelParser.T__56 - 12)) |
                     (1 <<
                      (ModelParser.T__57 - 12)) | (1 <<
                                                   (ModelParser.T__66 - 12)) |
                     (1 <<
                      (ModelParser.T__67 - 12)) | (1 <<
                                                   (ModelParser.T__68 - 12)) |
                     (1 << (ModelParser.FUNCTION - 12)) |
                     (1 << (ModelParser.KEYWORD - 12)) |
                     (1 <<
                      (ModelParser.NAME - 12)) | (1 <<
                                                  (ModelParser.INTEGER - 12)) |
                     (1 << (ModelParser.FLOATING - 12)))) != 0):
                self.state = 418
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__13:
                    self.state = 417
                    self.match(ModelParser.T__13)

                self.state = 420
                self.combination_item()
                self.state = 425
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 426
            self.match(ModelParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Combination_itemContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.any = None  # Token

        def combination_atom(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Combination_atomContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Combination_atomContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_combination_item

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCombination_item"):
                listener.enterCombination_item(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCombination_item"):
                listener.exitCombination_item(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCombination_item"):
                return visitor.visitCombination_item(self)
            else:
                return visitor.visitChildren(self)

    def combination_item(self):

        localctx = ModelParser.Combination_itemContext(self, self._ctx,
                                                       self.state)
        self.enterRule(localctx, 54, self.RULE_combination_item)
        self._la = 0  # Token type
        try:
            self.state = 443
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 52, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 428
                localctx.any = self.match(ModelParser.T__44)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 429
                self.match(ModelParser.T__12)
                self.state = 430
                self.combination_atom()
                self.state = 437
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (
                    (((_la - 12)) & ~0x3f) == 0 and
                    ((1 << (_la - 12)) &
                     ((1 << (ModelParser.T__11 - 12)) |
                      (1 <<
                       (ModelParser.T__12 - 12)) | (1 <<
                                                    (ModelParser.T__13 - 12)) |
                      (1 <<
                       (ModelParser.T__16 - 12)) | (1 <<
                                                    (ModelParser.T__46 - 12)) |
                      (1 <<
                       (ModelParser.T__47 - 12)) | (1 <<
                                                    (ModelParser.T__48 - 12)) |
                      (1 <<
                       (ModelParser.T__49 - 12)) | (1 <<
                                                    (ModelParser.T__50 - 12)) |
                      (1 <<
                       (ModelParser.T__51 - 12)) | (1 <<
                                                    (ModelParser.T__52 - 12)) |
                      (1 <<
                       (ModelParser.T__53 - 12)) | (1 <<
                                                    (ModelParser.T__54 - 12)) |
                      (1 <<
                       (ModelParser.T__55 - 12)) | (1 <<
                                                    (ModelParser.T__56 - 12)) |
                      (1 <<
                       (ModelParser.T__57 - 12)) | (1 <<
                                                    (ModelParser.T__66 - 12)) |
                      (1 <<
                       (ModelParser.T__67 - 12)) | (1 <<
                                                    (ModelParser.T__68 - 12)) |
                      (1 << (ModelParser.FUNCTION - 12)) |
                      (1 << (ModelParser.KEYWORD - 12)) |
                      (1 << (ModelParser.NAME - 12)) |
                      (1 << (ModelParser.INTEGER - 12)) |
                      (1 << (ModelParser.FLOATING - 12)))) != 0):
                    self.state = 432
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la == ModelParser.T__13:
                        self.state = 431
                        self.match(ModelParser.T__13)

                    self.state = 434
                    self.combination_atom()
                    self.state = 439
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 440
                self.match(ModelParser.T__14)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 442
                self.combination_atom()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Combination_atomContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # CompareContext

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def compare(self):
            return self.getTypedRuleContext(ModelParser.CompareContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_combination_atom

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCombination_atom"):
                listener.enterCombination_atom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCombination_atom"):
                listener.exitCombination_atom(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCombination_atom"):
                return visitor.visitCombination_atom(self)
            else:
                return visitor.visitChildren(self)

    def combination_atom(self):

        localctx = ModelParser.Combination_atomContext(self, self._ctx,
                                                       self.state)
        self.enterRule(localctx, 56, self.RULE_combination_atom)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 446
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and
                ((1 << _la) &
                 ((1 << ModelParser.T__11) | (1 << ModelParser.T__47) |
                  (1 << ModelParser.T__48) | (1 << ModelParser.T__49) |
                  (1 << ModelParser.T__50) | (1 << ModelParser.T__51) |
                  (1 << ModelParser.T__52) | (1 << ModelParser.T__53) |
                  (1 << ModelParser.T__54) | (1 << ModelParser.T__55) |
                  (1 << ModelParser.T__56) | (1 << ModelParser.T__57))) != 0):
                self.state = 445
                localctx.operator = self.compare()

            self.state = 448
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Stmt_endContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return ModelParser.RULE_stmt_end

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterStmt_end"):
                listener.enterStmt_end(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitStmt_end"):
                listener.exitStmt_end(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitStmt_end"):
                return visitor.visitStmt_end(self)
            else:
                return visitor.visitChildren(self)

    def stmt_end(self):

        localctx = ModelParser.Stmt_endContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_stmt_end)
        try:
            self.state = 452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 54, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 450
                self.match(ModelParser.T__45)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.wasNewline()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConstantContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def floating(self):
            return self.getTypedRuleContext(ModelParser.FloatingContext, 0)

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_constant

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterConstant"):
                listener.enterConstant(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitConstant"):
                listener.exitConstant(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitConstant"):
                return visitor.visitConstant(self)
            else:
                return visitor.visitChildren(self)

    def constant(self):

        localctx = ModelParser.ConstantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_constant)
        try:
            self.state = 456
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [
                    ModelParser.T__16, ModelParser.T__46, ModelParser.INTEGER,
                    ModelParser.FLOATING
            ]:
                self.enterOuterAlt(localctx, 1)
                self.state = 454
                self.floating()
                pass
            elif token in [
                    ModelParser.FUNCTION, ModelParser.KEYWORD, ModelParser.NAME
            ]:
                self.enterOuterAlt(localctx, 2)
                self.state = 455
                self.name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FloatingContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FLOATING(self):
            return self.getToken(ModelParser.FLOATING, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_floating

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFloating"):
                listener.enterFloating(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFloating"):
                listener.exitFloating(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFloating"):
                return visitor.visitFloating(self)
            else:
                return visitor.visitChildren(self)

    def floating(self):

        localctx = ModelParser.FloatingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_floating)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__16:
                self.state = 458
                self.match(ModelParser.T__16)

            self.state = 461
            _la = self._input.LA(1)
            if not (((((_la - 47)) & ~0x3f) == 0 and
                     ((1 <<
                       (_la - 47)) & ((1 << (ModelParser.T__46 - 47)) |
                                      (1 << (ModelParser.INTEGER - 47)) |
                                      (1 <<
                                       (ModelParser.FLOATING - 47)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CompareContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def getRuleIndex(self):
            return ModelParser.RULE_compare

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCompare"):
                listener.enterCompare(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCompare"):
                listener.exitCompare(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCompare"):
                return visitor.visitCompare(self)
            else:
                return visitor.visitChildren(self)

    def compare(self):

        localctx = ModelParser.CompareContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_compare)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 463
            _la = self._input.LA(1)
            if not ((((_la) & ~0x3f) == 0 and
                     ((1 << _la) &
                      ((1 << ModelParser.T__11) | (1 << ModelParser.T__47) |
                       (1 << ModelParser.T__48) | (1 << ModelParser.T__49) |
                       (1 << ModelParser.T__50) | (1 << ModelParser.T__51) |
                       (1 << ModelParser.T__52) | (1 << ModelParser.T__53) |
                       (1 << ModelParser.T__54) | (1 << ModelParser.T__55) |
                       (1 << ModelParser.T__56) |
                       (1 << ModelParser.T__57))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.text = None  # Token

        def NAME(self):
            return self.getToken(ModelParser.NAME, 0)

        def FLOATING(self):
            return self.getToken(ModelParser.FLOATING, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def TIMES(self):
            return self.getToken(ModelParser.TIMES, 0)

        def HASHES(self):
            return self.getToken(ModelParser.HASHES, 0)

        def FUNCTION(self):
            return self.getToken(ModelParser.FUNCTION, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_unit

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterUnit"):
                listener.enterUnit(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitUnit"):
                listener.exitUnit(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitUnit"):
                return visitor.visitUnit(self)
            else:
                return visitor.visitChildren(self)

    def unit(self):

        localctx = ModelParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_unit)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 465
            self.match(ModelParser.T__7)
            self.state = 466
            localctx.text = self._input.LT(1)
            _la = self._input.LA(1)
            if not (((((_la - 70)) & ~0x3f) == 0 and
                     ((1 <<
                       (_la - 70)) & ((1 << (ModelParser.FUNCTION - 70)) |
                                      (1 << (ModelParser.NAME - 70)) |
                                      (1 << (ModelParser.INTEGER - 70)) |
                                      (1 << (ModelParser.FLOATING - 70)) |
                                      (1 << (ModelParser.TIMES - 70)) |
                                      (1 <<
                                       (ModelParser.HASHES - 70)))) != 0)):
                localctx.text = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FractionContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.sign = None  # Token
            self.digits = None  # Token

        def HASHES(self):
            return self.getToken(ModelParser.HASHES, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_fraction

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFraction"):
                listener.enterFraction(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFraction"):
                listener.exitFraction(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFraction"):
                return visitor.visitFraction(self)
            else:
                return visitor.visitChildren(self)

    def fraction(self):

        localctx = ModelParser.FractionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_fraction)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 468
            localctx.sign = self._input.LT(1)
            _la = self._input.LA(1)
            if not (_la == ModelParser.T__58 or _la == ModelParser.T__59):
                localctx.sign = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 469
            localctx.digits = self.match(ModelParser.HASHES)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PathContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def path_item(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Path_itemContext)
            else:
                return self.getTypedRuleContext(ModelParser.Path_itemContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_path

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath"):
                listener.enterPath(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath"):
                listener.exitPath(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath"):
                return visitor.visitPath(self)
            else:
                return visitor.visitChildren(self)

    def path(self):

        localctx = ModelParser.PathContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_path)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self.path_item()
            self.state = 476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__58:
                self.state = 472
                self.match(ModelParser.T__58)
                self.state = 473
                self.path_item()
                self.state = 478
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Path_itemContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def name(self):
            return self.getTypedRuleContext(ModelParser.NameContext, 0)

        def path_index(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.Path_indexContext)
            else:
                return self.getTypedRuleContext(ModelParser.Path_indexContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_path_item

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath_item"):
                listener.enterPath_item(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath_item"):
                listener.exitPath_item(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath_item"):
                return visitor.visitPath_item(self)
            else:
                return visitor.visitChildren(self)

    def path_item(self):

        localctx = ModelParser.Path_itemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_path_item)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.name()
            self.state = 488
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la == ModelParser.T__60:
                self.state = 480
                self.match(ModelParser.T__60)
                self.state = 481
                self.path_index()
                self.state = 484
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__8:
                    self.state = 482
                    self.match(ModelParser.T__8)
                    self.state = 483
                    self.path_index()

                self.state = 486
                self.match(ModelParser.T__61)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Path_indexContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.index_variable = None  # Token

        def NAME(self):
            return self.getToken(ModelParser.NAME, 0)

        def INTEGER(self):
            return self.getToken(ModelParser.INTEGER, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_path_index

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterPath_index"):
                listener.enterPath_index(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitPath_index"):
                listener.exitPath_index(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitPath_index"):
                return visitor.visitPath_index(self)
            else:
                return visitor.visitChildren(self)

    def path_index(self):

        localctx = ModelParser.Path_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_path_index)
        self._la = 0  # Token type
        try:
            self.state = 497
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ModelParser.NAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 490
                localctx.index_variable = self.match(ModelParser.NAME)
                pass
            elif token in [ModelParser.INTEGER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 491
                self.match(ModelParser.INTEGER)
                pass
            elif token in [ModelParser.T__62]:
                self.enterOuterAlt(localctx, 3)
                self.state = 492
                self.match(ModelParser.T__62)
                self.state = 495
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la == ModelParser.T__16:
                    self.state = 493
                    self.match(ModelParser.T__16)
                    self.state = 494
                    self.match(ModelParser.INTEGER)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConditionContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_or(self):
            return self.getTypedRuleContext(ModelParser.Condition_orContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_condition

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition"):
                listener.enterCondition(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition"):
                listener.exitCondition(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition"):
                return visitor.visitCondition(self)
            else:
                return visitor.visitChildren(self)

    def condition(self):

        localctx = ModelParser.ConditionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_condition)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 499
            self.condition_or()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_orContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_and(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Condition_andContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Condition_andContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_condition_or

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_or"):
                listener.enterCondition_or(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_or"):
                listener.exitCondition_or(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition_or"):
                return visitor.visitCondition_or(self)
            else:
                return visitor.visitChildren(self)

    def condition_or(self):

        localctx = ModelParser.Condition_orContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_condition_or)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.condition_and()
            self.state = 506
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__63:
                self.state = 502
                self.match(ModelParser.T__63)
                self.state = 503
                self.condition_and()
                self.state = 508
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_andContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_not(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Condition_notContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Condition_notContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_condition_and

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_and"):
                listener.enterCondition_and(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_and"):
                listener.exitCondition_and(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition_and"):
                return visitor.visitCondition_and(self)
            else:
                return visitor.visitChildren(self)

    def condition_and(self):

        localctx = ModelParser.Condition_andContext(self, self._ctx,
                                                    self.state)
        self.enterRule(localctx, 80, self.RULE_condition_and)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 509
            self.condition_not()
            self.state = 514
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__64:
                self.state = 510
                self.match(ModelParser.T__64)
                self.state = 511
                self.condition_not()
                self.state = 516
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_notContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def condition_not(self):
            return self.getTypedRuleContext(ModelParser.Condition_notContext,
                                            0)

        def condition(self):
            return self.getTypedRuleContext(ModelParser.ConditionContext, 0)

        def condition_compare(self):
            return self.getTypedRuleContext(
                ModelParser.Condition_compareContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_condition_not

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_not"):
                listener.enterCondition_not(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_not"):
                listener.exitCondition_not(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition_not"):
                return visitor.visitCondition_not(self)
            else:
                return visitor.visitChildren(self)

    def condition_not(self):

        localctx = ModelParser.Condition_notContext(self, self._ctx,
                                                    self.state)
        self.enterRule(localctx, 82, self.RULE_condition_not)
        try:
            self.state = 524
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 64, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 517
                self.match(ModelParser.T__65)
                self.state = 518
                self.condition_not()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 519
                self.match(ModelParser.T__12)
                self.state = 520
                self.condition()
                self.state = 521
                self.match(ModelParser.T__14)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 523
                self.condition_compare()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_compareContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def condition_part(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Condition_partContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Condition_partContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_condition_compare

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_compare"):
                listener.enterCondition_compare(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_compare"):
                listener.exitCondition_compare(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition_compare"):
                return visitor.visitCondition_compare(self)
            else:
                return visitor.visitChildren(self)

    def condition_compare(self):

        localctx = ModelParser.Condition_compareContext(
            self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_condition_compare)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 526
            self.formula()
            self.state = 530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0
                   and ((1 << _la) &
                        ((1 << ModelParser.T__11) | (1 << ModelParser.T__47) |
                         (1 << ModelParser.T__48) | (1 << ModelParser.T__49) |
                         (1 << ModelParser.T__50) | (1 << ModelParser.T__51) |
                         (1 << ModelParser.T__52) | (1 << ModelParser.T__53) |
                         (1 << ModelParser.T__54) | (1 << ModelParser.T__55) |
                         (1 << ModelParser.T__56) |
                         (1 << ModelParser.T__57))) != 0):
                self.state = 527
                self.condition_part()
                self.state = 532
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Condition_partContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # CompareContext

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def compare(self):
            return self.getTypedRuleContext(ModelParser.CompareContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_condition_part

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterCondition_part"):
                listener.enterCondition_part(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitCondition_part"):
                listener.exitCondition_part(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitCondition_part"):
                return visitor.visitCondition_part(self)
            else:
                return visitor.visitChildren(self)

    def condition_part(self):

        localctx = ModelParser.Condition_partContext(self, self._ctx,
                                                     self.state)
        self.enterRule(localctx, 86, self.RULE_condition_part)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            localctx.operator = self.compare()
            self.state = 534
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class FormulaContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def formula_add(self):
            return self.getTypedRuleContext(ModelParser.Formula_addContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_formula

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula"):
                listener.enterFormula(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula"):
                listener.exitFormula(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula"):
                return visitor.visitFormula(self)
            else:
                return visitor.visitChildren(self)

    def formula(self):

        localctx = ModelParser.FormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_formula)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 536
            self.formula_add()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_addContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_sub(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Formula_subContext)
            else:
                return self.getTypedRuleContext(ModelParser.Formula_subContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_add

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_add"):
                listener.enterFormula_add(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_add"):
                listener.exitFormula_add(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_add"):
                return visitor.visitFormula_add(self)
            else:
                return visitor.visitChildren(self)

    def formula_add(self):

        localctx = ModelParser.Formula_addContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_formula_add)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 538
            self.formula_sub()
            self.state = 543
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 66, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 539
                    localctx.operator = self.match(ModelParser.T__66)
                    self.state = 540
                    self.formula_sub()
                self.state = 545
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 66, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_subContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_mul(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Formula_mulContext)
            else:
                return self.getTypedRuleContext(ModelParser.Formula_mulContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_sub

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_sub"):
                listener.enterFormula_sub(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_sub"):
                listener.exitFormula_sub(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_sub"):
                return visitor.visitFormula_sub(self)
            else:
                return visitor.visitChildren(self)

    def formula_sub(self):

        localctx = ModelParser.Formula_subContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_formula_sub)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 546
            self.formula_mul()
            self.state = 551
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input, 67, self._ctx)
            while _alt != 2 and _alt != ATN.INVALID_ALT_NUMBER:
                if _alt == 1:
                    self.state = 547
                    localctx.operator = self.match(ModelParser.T__16)
                    self.state = 548
                    self.formula_mul()
                self.state = 553
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input, 67, self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_mulContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_div(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Formula_divContext)
            else:
                return self.getTypedRuleContext(ModelParser.Formula_divContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_mul

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_mul"):
                listener.enterFormula_mul(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_mul"):
                listener.exitFormula_mul(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_mul"):
                return visitor.visitFormula_mul(self)
            else:
                return visitor.visitChildren(self)

    def formula_mul(self):

        localctx = ModelParser.Formula_mulContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_formula_mul)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 554
            self.formula_div()
            self.state = 559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__9:
                self.state = 555
                localctx.operator = self.match(ModelParser.T__9)
                self.state = 556
                self.formula_div()
                self.state = 561
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_divContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_pow(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Formula_powContext)
            else:
                return self.getTypedRuleContext(ModelParser.Formula_powContext,
                                                i)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_div

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_div"):
                listener.enterFormula_div(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_div"):
                listener.exitFormula_div(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_div"):
                return visitor.visitFormula_div(self)
            else:
                return visitor.visitChildren(self)

    def formula_div(self):

        localctx = ModelParser.Formula_divContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_formula_div)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 562
            self.formula_pow()
            self.state = 567
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__7:
                self.state = 563
                localctx.operator = self.match(ModelParser.T__7)
                self.state = 564
                self.formula_pow()
                self.state = 569
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_powContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.operator = None  # Token

        def formula_sign(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(
                    ModelParser.Formula_signContext)
            else:
                return self.getTypedRuleContext(
                    ModelParser.Formula_signContext, i)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_pow

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_pow"):
                listener.enterFormula_pow(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_pow"):
                listener.exitFormula_pow(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_pow"):
                return visitor.visitFormula_pow(self)
            else:
                return visitor.visitChildren(self)

    def formula_pow(self):

        localctx = ModelParser.Formula_powContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_formula_pow)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 570
            self.formula_sign()
            self.state = 575
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__59:
                self.state = 571
                localctx.operator = self.match(ModelParser.T__59)
                self.state = 572
                self.formula_sign()
                self.state = 577
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_signContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.neg = None  # Formula_signContext

        def formula_sign(self):
            return self.getTypedRuleContext(ModelParser.Formula_signContext, 0)

        def formula(self):
            return self.getTypedRuleContext(ModelParser.FormulaContext, 0)

        def formula_func(self):
            return self.getTypedRuleContext(ModelParser.Formula_funcContext, 0)

        def formula_atom(self):
            return self.getTypedRuleContext(ModelParser.Formula_atomContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_sign

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_sign"):
                listener.enterFormula_sign(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_sign"):
                listener.exitFormula_sign(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_sign"):
                return visitor.visitFormula_sign(self)
            else:
                return visitor.visitChildren(self)

    def formula_sign(self):

        localctx = ModelParser.Formula_signContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_formula_sign)
        try:
            self.state = 588
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input, 71, self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 578
                self.match(ModelParser.T__16)
                self.state = 579
                localctx.neg = self.formula_sign()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 580
                self.match(ModelParser.T__66)
                self.state = 581
                self.formula_sign()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 582
                self.match(ModelParser.T__12)
                self.state = 583
                self.formula()
                self.state = 584
                self.match(ModelParser.T__14)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 586
                self.formula_func()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 587
                self.formula_atom()
                pass

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_funcContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.fun = None  # Token

        def formula(self, i: int = None):
            if i is None:
                return self.getTypedRuleContexts(ModelParser.FormulaContext)
            else:
                return self.getTypedRuleContext(ModelParser.FormulaContext, i)

        def FUNCTION(self):
            return self.getToken(ModelParser.FUNCTION, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_func

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_func"):
                listener.enterFormula_func(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_func"):
                listener.exitFormula_func(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_func"):
                return visitor.visitFormula_func(self)
            else:
                return visitor.visitChildren(self)

    def formula_func(self):

        localctx = ModelParser.Formula_funcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_formula_func)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 590
            localctx.fun = self.match(ModelParser.FUNCTION)
            self.state = 591
            self.match(ModelParser.T__12)
            self.state = 592
            self.formula()
            self.state = 597
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la == ModelParser.T__13:
                self.state = 593
                self.match(ModelParser.T__13)
                self.state = 594
                self.formula()
                self.state = 599
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 600
            self.match(ModelParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Formula_atomContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.atom_true = None  # Token
            self.atom_false = None  # Token
            self.atom_num = None  # FloatingContext
            self.atom_path = None  # PathContext

        def floating(self):
            return self.getTypedRuleContext(ModelParser.FloatingContext, 0)

        def path(self):
            return self.getTypedRuleContext(ModelParser.PathContext, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_formula_atom

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterFormula_atom"):
                listener.enterFormula_atom(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitFormula_atom"):
                listener.exitFormula_atom(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitFormula_atom"):
                return visitor.visitFormula_atom(self)
            else:
                return visitor.visitChildren(self)

    def formula_atom(self):

        localctx = ModelParser.Formula_atomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_formula_atom)
        try:
            self.state = 606
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [ModelParser.T__67]:
                self.enterOuterAlt(localctx, 1)
                self.state = 602
                localctx.atom_true = self.match(ModelParser.T__67)
                pass
            elif token in [ModelParser.T__68]:
                self.enterOuterAlt(localctx, 2)
                self.state = 603
                localctx.atom_false = self.match(ModelParser.T__68)
                pass
            elif token in [
                    ModelParser.T__16, ModelParser.T__46, ModelParser.INTEGER,
                    ModelParser.FLOATING
            ]:
                self.enterOuterAlt(localctx, 3)
                self.state = 604
                localctx.atom_num = self.floating()
                pass
            elif token in [
                    ModelParser.FUNCTION, ModelParser.KEYWORD, ModelParser.NAME
            ]:
                self.enterOuterAlt(localctx, 4)
                self.state = 605
                localctx.atom_path = self.path()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class NameContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NAME(self):
            return self.getToken(ModelParser.NAME, 0)

        def FUNCTION(self):
            return self.getToken(ModelParser.FUNCTION, 0)

        def KEYWORD(self):
            return self.getToken(ModelParser.KEYWORD, 0)

        def getRuleIndex(self):
            return ModelParser.RULE_name

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterName"):
                listener.enterName(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitName"):
                listener.exitName(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitName"):
                return visitor.visitName(self)
            else:
                return visitor.visitChildren(self)

    def name(self):

        localctx = ModelParser.NameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_name)
        self._la = 0  # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 608
            _la = self._input.LA(1)
            if not (((((_la - 70)) & ~0x3f) == 0 and
                     ((1 << (_la - 70)) & ((1 << (ModelParser.FUNCTION - 70)) |
                                           (1 << (ModelParser.KEYWORD - 70)) |
                                           (1 <<
                                            (ModelParser.NAME - 70)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DateContext(ParserRuleContext):

        def __init__(self,
                     parser,
                     parent: ParserRuleContext = None,
                     invokingState: int = -1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.year = None  # Token
            self.month = None  # Token
            self.day = None  # Token

        def INTEGER(self, i: int = None):
            if i is None:
                return self.getTokens(ModelParser.INTEGER)
            else:
                return self.getToken(ModelParser.INTEGER, i)

        def getRuleIndex(self):
            return ModelParser.RULE_date

        def enterRule(self, listener: ParseTreeListener):
            if hasattr(listener, "enterDate"):
                listener.enterDate(self)

        def exitRule(self, listener: ParseTreeListener):
            if hasattr(listener, "exitDate"):
                listener.exitDate(self)

        def accept(self, visitor: ParseTreeVisitor):
            if hasattr(visitor, "visitDate"):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)

    def date(self):

        localctx = ModelParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_date)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 610
            localctx.year = self.match(ModelParser.INTEGER)
            self.state = 611
            self.match(ModelParser.T__16)
            self.state = 612
            localctx.month = self.match(ModelParser.INTEGER)
            self.state = 613
            self.match(ModelParser.T__16)
            self.state = 614
            localctx.day = self.match(ModelParser.INTEGER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx
